
// nv_ram_rwsthp_20x4: synthesizable model core
// Generated by /home/nvtools/branch/release/t194_rg/2017/06/01_10_25_11/nvtools/rams/scripts/ramgen - DO NOT EDIT
// Estimated area:     174.18 um^2 (nvstd_tsmc16fflr)


`ifdef _SIMULATE_X_VH_
`else

`ifndef SYNTHESIS
`define tick_x_or_0  1'bx
`define tick_x_or_1  1'bx
`else
`define tick_x_or_0  1'b0
`define tick_x_or_1  1'b1
`endif

`endif


// verilint 549 off - async flop inferred
// verilint 446 off - reading from output port
// verilint 389 off - multiple clocks in module
// verilint 287 off - unconnected ports
// verilint 401 off - Clock is not an input to the module (we use gated clk)
// verilint 257 off - delays ignored by synth tools
// verilint 240 off - Unused input
// verilint 542 off - enabled flop inferred
// verilint 210 off - too few module ports
// verilint 280 off - delay in non-blocking assignment
// verilint 332 off - not all possible cases covered, but default case exists
// verilint 390 off - multiple resets in this module
// verilint 396 off - flop w/o async reset
// verilint 69 off - case without default, all cases covered
// verilint 34 off - unused macro
// verilint 528 off - variable set but not used
// verilint 530 off - flop inferred
// verilint 550 off - mux inferred
// verilint 113 off - multiple drivers to flop
// leda ELB072 off

`timescale 1ns / 10ps


module nv_ram_rwsthp_20x4_logic (
               byp_sel,
               clk,
               dbyp,
               di,
               dout,
               ore,
               pwrbus_ram_pd,
               ra,
               re,
               scan_en,
               wa,
               we
        );
parameter FORCE_CONTENTION_ASSERTION_RESET_ACTIVE=1'b0;

// port list for submodule
input           byp_sel;
input           clk;
input  [3:0]    dbyp;
input  [3:0]    di;
output [3:0]    dout;
input           ore;
input  [31:0]   pwrbus_ram_pd;
input  [4:0]    ra;
input           re;
input           scan_en;
input  [4:0]    wa;
input           we;


wire [7:0] sleep_en = pwrbus_ram_pd[7:0];
wire  ret_en = pwrbus_ram_pd[8];
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_9 (.A(pwrbus_ram_pd[9]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_10 (.A(pwrbus_ram_pd[10]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_11 (.A(pwrbus_ram_pd[11]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_12 (.A(pwrbus_ram_pd[12]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_13 (.A(pwrbus_ram_pd[13]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_14 (.A(pwrbus_ram_pd[14]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_15 (.A(pwrbus_ram_pd[15]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_16 (.A(pwrbus_ram_pd[16]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_17 (.A(pwrbus_ram_pd[17]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_18 (.A(pwrbus_ram_pd[18]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_19 (.A(pwrbus_ram_pd[19]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_20 (.A(pwrbus_ram_pd[20]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_21 (.A(pwrbus_ram_pd[21]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_22 (.A(pwrbus_ram_pd[22]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_23 (.A(pwrbus_ram_pd[23]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_24 (.A(pwrbus_ram_pd[24]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_25 (.A(pwrbus_ram_pd[25]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_26 (.A(pwrbus_ram_pd[26]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_27 (.A(pwrbus_ram_pd[27]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_28 (.A(pwrbus_ram_pd[28]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_29 (.A(pwrbus_ram_pd[29]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_30 (.A(pwrbus_ram_pd[30]));
NV_BLKBOX_SINK UJ_BBOX2UNIT_UNUSED_pwrbus_31 (.A(pwrbus_ram_pd[31]));
reg [4:0] Ra_array_reg_r0;

// Declare the Data_reg signal beforehand
// verilint 498 off - not all bits are used
reg [3:0] Data_reg_r0;


 // Data out bus for read port r0 for Output Mux
wire [3:0] r0_OutputMuxDataOut;

reg [4:0] Ra_reg_r0;

// Write enable bus
wire  we_0_0;
// start of predeclareNvregSignals
wire ctx_ctrl_we;
wire [4:0] D_Ra_array_reg_r0;

wire [4:0] la_muxedRa_r0;
assign D_Ra_array_reg_r0 = ( ((re)))  ? ra : Ra_array_reg_r0;


always @(posedge clk) begin
    Ra_array_reg_r0 <= D_Ra_array_reg_r0;
 end
assign la_muxedRa_r0 = Ra_array_reg_r0;

// ------------------  START PIECE ----------------------------------
// Suffix  : Piece Flop_Array (FlopArray)
// Covers Addresses from 0 to 19  Addressrange: [4:0]  
// Data Bit range: [3:0] (4 bits)   
// Enables: 1   Enable range: 




// Write Address bus

wire [4:0] wa_0_0;
assign wa_0_0 = wa;

// Write Data in bus
wire [3:0] di_0_0;
assign di_0_0 = di[3:0];
assign we_0_0 = we;

// Read Address bus
wire [4:0] ra_0_0;
assign ra_0_0 = la_muxedRa_r0;

// Read DataOut bus
wire [3:0] dout_0_0;


// begin ----------------  Flop_Array ---------------


// Declare the register array
reg [3:0] FlopArray_row0;
reg [3:0] FlopArray_row1;
reg [3:0] FlopArray_row2;
reg [3:0] FlopArray_row3;
reg [3:0] FlopArray_row4;
reg [3:0] FlopArray_row5;
reg [3:0] FlopArray_row6;
reg [3:0] FlopArray_row7;
reg [3:0] FlopArray_row8;
reg [3:0] FlopArray_row9;
reg [3:0] FlopArray_row10;
reg [3:0] FlopArray_row11;
reg [3:0] FlopArray_row12;
reg [3:0] FlopArray_row13;
reg [3:0] FlopArray_row14;
reg [3:0] FlopArray_row15;
reg [3:0] FlopArray_row16;
reg [3:0] FlopArray_row17;
reg [3:0] FlopArray_row18;
reg [3:0] FlopArray_row19;

// Declare the Write port wires

// Write Data wires

wire [3:0] Wdata;

// Assign for data input
assign Wdata = di_0_0;
    

// Address decode for Flop array 
wire [19:0] Wa_decode;


// Create wire for one write enable
wire   We;
assign We = we_0_0;

assign Wa_decode[0] = We & (wa_0_0 == 5'd0);
assign Wa_decode[1] = We & (wa_0_0 == 5'd1);
assign Wa_decode[2] = We & (wa_0_0 == 5'd2);
assign Wa_decode[3] = We & (wa_0_0 == 5'd3);
assign Wa_decode[4] = We & (wa_0_0 == 5'd4);
assign Wa_decode[5] = We & (wa_0_0 == 5'd5);
assign Wa_decode[6] = We & (wa_0_0 == 5'd6);
assign Wa_decode[7] = We & (wa_0_0 == 5'd7);
assign Wa_decode[8] = We & (wa_0_0 == 5'd8);
assign Wa_decode[9] = We & (wa_0_0 == 5'd9);
assign Wa_decode[10] = We & (wa_0_0 == 5'd10);
assign Wa_decode[11] = We & (wa_0_0 == 5'd11);
assign Wa_decode[12] = We & (wa_0_0 == 5'd12);
assign Wa_decode[13] = We & (wa_0_0 == 5'd13);
assign Wa_decode[14] = We & (wa_0_0 == 5'd14);
assign Wa_decode[15] = We & (wa_0_0 == 5'd15);
assign Wa_decode[16] = We & (wa_0_0 == 5'd16);
assign Wa_decode[17] = We & (wa_0_0 == 5'd17);
assign Wa_decode[18] = We & (wa_0_0 == 5'd18);
assign Wa_decode[19] = We & (wa_0_0 == 5'd19);
reg [3:0] RaDecodeDor0;

// Assign the input data to the flop input
wire [3:0] FlopArray_row0_d;
assign FlopArray_row0_d =  (Wa_decode[0]) ? Wdata : FlopArray_row0;

wire [3:0] FlopArray_row1_d;
assign FlopArray_row1_d =  (Wa_decode[1]) ? Wdata : FlopArray_row1;

wire [3:0] FlopArray_row2_d;
assign FlopArray_row2_d =  (Wa_decode[2]) ? Wdata : FlopArray_row2;

wire [3:0] FlopArray_row3_d;
assign FlopArray_row3_d =  (Wa_decode[3]) ? Wdata : FlopArray_row3;

wire [3:0] FlopArray_row4_d;
assign FlopArray_row4_d =  (Wa_decode[4]) ? Wdata : FlopArray_row4;

wire [3:0] FlopArray_row5_d;
assign FlopArray_row5_d =  (Wa_decode[5]) ? Wdata : FlopArray_row5;

wire [3:0] FlopArray_row6_d;
assign FlopArray_row6_d =  (Wa_decode[6]) ? Wdata : FlopArray_row6;

wire [3:0] FlopArray_row7_d;
assign FlopArray_row7_d =  (Wa_decode[7]) ? Wdata : FlopArray_row7;

wire [3:0] FlopArray_row8_d;
assign FlopArray_row8_d =  (Wa_decode[8]) ? Wdata : FlopArray_row8;

wire [3:0] FlopArray_row9_d;
assign FlopArray_row9_d =  (Wa_decode[9]) ? Wdata : FlopArray_row9;

wire [3:0] FlopArray_row10_d;
assign FlopArray_row10_d =  (Wa_decode[10]) ? Wdata : FlopArray_row10;

wire [3:0] FlopArray_row11_d;
assign FlopArray_row11_d =  (Wa_decode[11]) ? Wdata : FlopArray_row11;

wire [3:0] FlopArray_row12_d;
assign FlopArray_row12_d =  (Wa_decode[12]) ? Wdata : FlopArray_row12;

wire [3:0] FlopArray_row13_d;
assign FlopArray_row13_d =  (Wa_decode[13]) ? Wdata : FlopArray_row13;

wire [3:0] FlopArray_row14_d;
assign FlopArray_row14_d =  (Wa_decode[14]) ? Wdata : FlopArray_row14;

wire [3:0] FlopArray_row15_d;
assign FlopArray_row15_d =  (Wa_decode[15]) ? Wdata : FlopArray_row15;

wire [3:0] FlopArray_row16_d;
assign FlopArray_row16_d =  (Wa_decode[16]) ? Wdata : FlopArray_row16;

wire [3:0] FlopArray_row17_d;
assign FlopArray_row17_d =  (Wa_decode[17]) ? Wdata : FlopArray_row17;

wire [3:0] FlopArray_row18_d;
assign FlopArray_row18_d =  (Wa_decode[18]) ? Wdata : FlopArray_row18;

wire [3:0] FlopArray_row19_d;
assign FlopArray_row19_d =  (Wa_decode[19]) ? Wdata : FlopArray_row19;

always @(posedge clk) begin
   FlopArray_row0 <=  FlopArray_row0_d;

   FlopArray_row1 <=  FlopArray_row1_d;

   FlopArray_row2 <=  FlopArray_row2_d;

   FlopArray_row3 <=  FlopArray_row3_d;

   FlopArray_row4 <=  FlopArray_row4_d;

   FlopArray_row5 <=  FlopArray_row5_d;

   FlopArray_row6 <=  FlopArray_row6_d;

   FlopArray_row7 <=  FlopArray_row7_d;

   FlopArray_row8 <=  FlopArray_row8_d;

   FlopArray_row9 <=  FlopArray_row9_d;

   FlopArray_row10 <=  FlopArray_row10_d;

   FlopArray_row11 <=  FlopArray_row11_d;

   FlopArray_row12 <=  FlopArray_row12_d;

   FlopArray_row13 <=  FlopArray_row13_d;

   FlopArray_row14 <=  FlopArray_row14_d;

   FlopArray_row15 <=  FlopArray_row15_d;

   FlopArray_row16 <=  FlopArray_row16_d;

   FlopArray_row17 <=  FlopArray_row17_d;

   FlopArray_row18 <=  FlopArray_row18_d;

   FlopArray_row19 <=  FlopArray_row19_d;

end


// Declare the Do buses for data out.


// Do Ra decode

always @(ra_0_0 or FlopArray_row0 or FlopArray_row1 or FlopArray_row2 or 
         FlopArray_row3 or FlopArray_row4 or FlopArray_row5 or FlopArray_row6 or 
         FlopArray_row7 or FlopArray_row8 or FlopArray_row9 or FlopArray_row10 or 
         FlopArray_row11 or FlopArray_row12 or FlopArray_row13 or 
         FlopArray_row14 or FlopArray_row15 or FlopArray_row16 or 
         FlopArray_row17 or FlopArray_row18 or FlopArray_row19)
   // verilint 332 off - not all cases covered, default exists
   case(ra_0_0)
       5'd0 : RaDecodeDor0 = FlopArray_row0;
       5'd1 : RaDecodeDor0 = FlopArray_row1;
       5'd2 : RaDecodeDor0 = FlopArray_row2;
       5'd3 : RaDecodeDor0 = FlopArray_row3;
       5'd4 : RaDecodeDor0 = FlopArray_row4;
       5'd5 : RaDecodeDor0 = FlopArray_row5;
       5'd6 : RaDecodeDor0 = FlopArray_row6;
       5'd7 : RaDecodeDor0 = FlopArray_row7;
       5'd8 : RaDecodeDor0 = FlopArray_row8;
       5'd9 : RaDecodeDor0 = FlopArray_row9;
       5'd10 : RaDecodeDor0 = FlopArray_row10;
       5'd11 : RaDecodeDor0 = FlopArray_row11;
       5'd12 : RaDecodeDor0 = FlopArray_row12;
       5'd13 : RaDecodeDor0 = FlopArray_row13;
       5'd14 : RaDecodeDor0 = FlopArray_row14;
       5'd15 : RaDecodeDor0 = FlopArray_row15;
       5'd16 : RaDecodeDor0 = FlopArray_row16;
       5'd17 : RaDecodeDor0 = FlopArray_row17;
       5'd18 : RaDecodeDor0 = FlopArray_row18;
       5'd19 : RaDecodeDor0 = FlopArray_row19;
       default :RaDecodeDor0 = {4{`tick_x_or_0}};
    endcase

   // verilint 332 on

assign dout_0_0 = RaDecodeDor0;


//------------ Done generating flop array Flop_Array -------------


// --------------------------------------------- 

// Declare the interface wires for Output Mux logic


// verilint 552 off - Different bits of a net are driven in different blocks (harmless, 
// but some synthesis tools generate a warning for this)
reg [3:0] ram_r0_OutputMuxDataOut;

//For bitEnd 3, only one piece Flop_Array in the column.

// verilint 17 off - Range (rather than full vector) in the sensitivity list
always @(dout_0_0)
      ram_r0_OutputMuxDataOut[3:0] = dout_0_0;
assign r0_OutputMuxDataOut[3:0] = ram_r0_OutputMuxDataOut[3:0];
// verilint 17 on - Range (rather than full vector) in the sensitivity list



// --------------------- Output Mbist Interface logic  -------------

wire [3:0] functional_byp_r0_OutputMuxDataOut = (byp_sel) ? dbyp : r0_OutputMuxDataOut;
wire [3:0] muxed_r0_OutputMuxDataOut;
assign muxed_r0_OutputMuxDataOut = ( | (byp_sel)) ? functional_byp_r0_OutputMuxDataOut : r0_OutputMuxDataOut;
wire captureDR_r0 = ((((ore))) || ( 1'b0 ));
////MSB 3 LSB 0  and total rambit is 0 and  dsize is 4

always @(posedge clk) begin

    if (captureDR_r0)
       Data_reg_r0[3:0] <= muxed_r0_OutputMuxDataOut[3:0];  
end
assign dout = Data_reg_r0;


// Ram access scan chain 

`ifdef ASSERT_ON
`ifndef SYNTHESIS
reg sim_reset_;
initial sim_reset_ = 0;
always @(posedge clk) sim_reset_ <= 1'b1;

wire start_of_sim = sim_reset_;


wire disable_clk_x_test = $test$plusargs ("disable_clk_x_test") ? 1'b1 : 1'b0;
nv_assert_no_x #(1,1,0," Try Reading Ram when clock is x for read port r0") _clk_x_test_read (clk, sim_reset_, ((disable_clk_x_test===1'b0) && (|re===1'b1 )), clk);
nv_assert_no_x #(1,1,0," Try Writing Ram when clock is x for write port w0") _clk_x_test_write (clk, sim_reset_, ((disable_clk_x_test===1'b0) && (|we===1'b1)), clk);
`endif // SYNTHESIS 
`endif // ASSERT_ON

`ifdef ASSERT_ON
`ifndef SYNTHESIS
`endif
`endif

`ifdef ASSERT_ON
`ifndef SYNTHESIS
wire pwrbus_assertion_not_x_while_active = $test$plusargs ("pwrbus_assertion_not_x_while_active");
nv_assert_never #(0, 0, "Power bus cannot be X when read/write enable is set") _pwrbus_assertion_not_x_while_active_we ( we, sim_reset_ && !pwrbus_assertion_not_x_while_active, ^pwrbus_ram_pd === 1'bx);
nv_assert_never #(0, 0, "Power bus cannot be X when read/write enable is set") _pwrbus_assertion_not_x_while_active_re ( re, sim_reset_ && !pwrbus_assertion_not_x_while_active, ^pwrbus_ram_pd === 1'bx);
`endif
`endif

// submodule done
endmodule
