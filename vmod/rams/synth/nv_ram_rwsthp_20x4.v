// nv_ram_rwsthp_20x4: synthesizable model wrapper
// Generated by /home/nvtools/branch/release/t194_rg/2017/06/01_10_25_11/nvtools/rams/scripts/ramgen - DO NOT EDIT
// Estimated area:     174.18 um^2 (nvstd_tsmc16fflr)
// Option explanations:
// p: 
// Causes read ports to have their outputs flopped.  
//           The 'ore' input is used as a load enable on the output flop
//           stage.  This flop stage tends to be nearly free, since some
//           flops are generally required for testability purposes.
// s: 
// Indicates that the ram is synchronous (i.e. all 
//           ports use the same clock).  The one or more clk(_[rw])[0-9]* 
//           ports will be replaced with a single 'clk' port.
// h: 
// Functional bypass option creates a bypass_di port and a control port.
//           When the control is asserted, bypass_di is floped into the data register instead
//           of RAM core output.
// t: 
// Indicates that write-through capability is necessary.  
//           This allows a read of an entry that is currently being
//           written to result in correct (new) data.  This option is
//           only allowed for synchronous rams, and usually results in a
//           bypass path being built around the main storage.

// leda ELB072 off
`timescale 1ns / 10ps

module nv_ram_rwsthp_20x4 (
        clk,
        ra,
        re,
        ore,
        dout,
        wa,
        we,
        di,
        byp_sel,
        dbyp,
        pwrbus_ram_pd
        );
parameter FORCE_CONTENTION_ASSERTION_RESET_ACTIVE=1'b0;

// port list
input           clk;
input  [4:0]    ra;
input           re;
input           ore;
output [3:0]    dout;
input  [4:0]    wa;
input           we;
input  [3:0]    di;
input           byp_sel;
input  [3:0]    dbyp;
input  [31:0]   pwrbus_ram_pd;



// This wrapper consists of :  1 Flop Arrays; 

//Wires for Misc Ports 
wire  DFT_clamp;

//Wires for Misc Ports 
wire  scan_en;

// Use Bbox and clamps to clamp and tie off the DFT signals in the wrapper 
NV_BLKBOX_SRC0 UI_enableDFTmode_async_ld_buf (.Y(DFT_clamp));
wire pre_scan_en;
NV_BLKBOX_SRC0_X testInst_scan_en (.Y(pre_scan_en));
AN2D4PO4 UJ_DFTQUALIFIER_scan_en (.Z(scan_en), .A1(pre_scan_en), .A2(DFT_clamp) );

// Declare the wires for test signals

// Instantiating the internal logic module now
// verilint 402 off - inferred Reset must be a module port
nv_ram_rwsthp_20x4_logic #(FORCE_CONTENTION_ASSERTION_RESET_ACTIVE) r_nv_ram_rwsthp_20x4 (
                           .byp_sel(byp_sel), .clk(clk), .dbyp(dbyp), .di(di), 
                           .dout(dout), .ore(ore), .pwrbus_ram_pd(pwrbus_ram_pd), 
                           .ra(ra), .re(re), .scan_en(scan_en), .wa(wa), .we(we)
                            );
// verilint 402 on - inferred Reset must be a module port


// synopsys dc_tcl_script_begin
  // set_dont_touch [get_cells "testInst_scan_en"]
// synopsys dc_tcl_script_end



// synopsys dc_tcl_script_begin
  // set_dont_touch [get_nets "scan_en"]
// synopsys dc_tcl_script_end


`ifndef SYNTHESIS
task arrangement (output integer arrangment_string[3:0]);
  begin
    arrangment_string[0] = 0  ;     
    arrangment_string[1] = 1  ;     
    arrangment_string[2] = 2  ;     
    arrangment_string[3] = 3  ;     
  end
endtask
`endif

`ifndef SYNTHESIS
`ifndef NO_INIT_MEM_VAL_TASKS

`ifndef MEM_REG_NAME 
 `define MEM_REG_NAME MX.mem
`endif

// Bit vector indicating which shadow addresses have been written
reg [19:0] shadow_written = 'b0;

// Shadow ram array used to store initialization values
reg [3:0] shadow_mem [19:0];


`ifdef NV_RAM_EXPAND_ARRAY
wire [3:0] shadow_mem_row0 = shadow_mem[0];
wire [3:0] shadow_mem_row1 = shadow_mem[1];
wire [3:0] shadow_mem_row2 = shadow_mem[2];
wire [3:0] shadow_mem_row3 = shadow_mem[3];
wire [3:0] shadow_mem_row4 = shadow_mem[4];
wire [3:0] shadow_mem_row5 = shadow_mem[5];
wire [3:0] shadow_mem_row6 = shadow_mem[6];
wire [3:0] shadow_mem_row7 = shadow_mem[7];
wire [3:0] shadow_mem_row8 = shadow_mem[8];
wire [3:0] shadow_mem_row9 = shadow_mem[9];
wire [3:0] shadow_mem_row10 = shadow_mem[10];
wire [3:0] shadow_mem_row11 = shadow_mem[11];
wire [3:0] shadow_mem_row12 = shadow_mem[12];
wire [3:0] shadow_mem_row13 = shadow_mem[13];
wire [3:0] shadow_mem_row14 = shadow_mem[14];
wire [3:0] shadow_mem_row15 = shadow_mem[15];
wire [3:0] shadow_mem_row16 = shadow_mem[16];
wire [3:0] shadow_mem_row17 = shadow_mem[17];
wire [3:0] shadow_mem_row18 = shadow_mem[18];
wire [3:0] shadow_mem_row19 = shadow_mem[19];
`endif

task init_mem_val;
  input [4:0] row;
  input [3:0] data;
  begin
    shadow_mem[row] = data;
    shadow_written[row] = 1'b1;
  end
endtask

task init_mem_commit;
integer row;
begin

// initializing Flop_Array
if (shadow_written[0]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row0 = shadow_mem[0][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row0_d = shadow_mem[0][3:0];
end 
if (shadow_written[1]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row1 = shadow_mem[1][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row1_d = shadow_mem[1][3:0];
end 
if (shadow_written[2]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row2 = shadow_mem[2][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row2_d = shadow_mem[2][3:0];
end 
if (shadow_written[3]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row3 = shadow_mem[3][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row3_d = shadow_mem[3][3:0];
end 
if (shadow_written[4]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row4 = shadow_mem[4][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row4_d = shadow_mem[4][3:0];
end 
if (shadow_written[5]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row5 = shadow_mem[5][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row5_d = shadow_mem[5][3:0];
end 
if (shadow_written[6]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row6 = shadow_mem[6][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row6_d = shadow_mem[6][3:0];
end 
if (shadow_written[7]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row7 = shadow_mem[7][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row7_d = shadow_mem[7][3:0];
end 
if (shadow_written[8]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row8 = shadow_mem[8][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row8_d = shadow_mem[8][3:0];
end 
if (shadow_written[9]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row9 = shadow_mem[9][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row9_d = shadow_mem[9][3:0];
end 
if (shadow_written[10]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row10 = shadow_mem[10][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row10_d = shadow_mem[10][3:0];
end 
if (shadow_written[11]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row11 = shadow_mem[11][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row11_d = shadow_mem[11][3:0];
end 
if (shadow_written[12]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row12 = shadow_mem[12][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row12_d = shadow_mem[12][3:0];
end 
if (shadow_written[13]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row13 = shadow_mem[13][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row13_d = shadow_mem[13][3:0];
end 
if (shadow_written[14]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row14 = shadow_mem[14][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row14_d = shadow_mem[14][3:0];
end 
if (shadow_written[15]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row15 = shadow_mem[15][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row15_d = shadow_mem[15][3:0];
end 
if (shadow_written[16]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row16 = shadow_mem[16][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row16_d = shadow_mem[16][3:0];
end 
if (shadow_written[17]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row17 = shadow_mem[17][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row17_d = shadow_mem[17][3:0];
end 
if (shadow_written[18]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row18 = shadow_mem[18][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row18_d = shadow_mem[18][3:0];
end 
if (shadow_written[19]) begin 
    r_nv_ram_rwsthp_20x4.FlopArray_row19 = shadow_mem[19][3:0];
    force r_nv_ram_rwsthp_20x4.FlopArray_row19_d = shadow_mem[19][3:0];
end 
#1 ;
if (shadow_written[0]) release r_nv_ram_rwsthp_20x4.FlopArray_row0_d;
if (shadow_written[1]) release r_nv_ram_rwsthp_20x4.FlopArray_row1_d;
if (shadow_written[2]) release r_nv_ram_rwsthp_20x4.FlopArray_row2_d;
if (shadow_written[3]) release r_nv_ram_rwsthp_20x4.FlopArray_row3_d;
if (shadow_written[4]) release r_nv_ram_rwsthp_20x4.FlopArray_row4_d;
if (shadow_written[5]) release r_nv_ram_rwsthp_20x4.FlopArray_row5_d;
if (shadow_written[6]) release r_nv_ram_rwsthp_20x4.FlopArray_row6_d;
if (shadow_written[7]) release r_nv_ram_rwsthp_20x4.FlopArray_row7_d;
if (shadow_written[8]) release r_nv_ram_rwsthp_20x4.FlopArray_row8_d;
if (shadow_written[9]) release r_nv_ram_rwsthp_20x4.FlopArray_row9_d;
if (shadow_written[10]) release r_nv_ram_rwsthp_20x4.FlopArray_row10_d;
if (shadow_written[11]) release r_nv_ram_rwsthp_20x4.FlopArray_row11_d;
if (shadow_written[12]) release r_nv_ram_rwsthp_20x4.FlopArray_row12_d;
if (shadow_written[13]) release r_nv_ram_rwsthp_20x4.FlopArray_row13_d;
if (shadow_written[14]) release r_nv_ram_rwsthp_20x4.FlopArray_row14_d;
if (shadow_written[15]) release r_nv_ram_rwsthp_20x4.FlopArray_row15_d;
if (shadow_written[16]) release r_nv_ram_rwsthp_20x4.FlopArray_row16_d;
if (shadow_written[17]) release r_nv_ram_rwsthp_20x4.FlopArray_row17_d;
if (shadow_written[18]) release r_nv_ram_rwsthp_20x4.FlopArray_row18_d;
if (shadow_written[19]) release r_nv_ram_rwsthp_20x4.FlopArray_row19_d;

shadow_written = 'b0;
end
endtask
`endif
`endif
`ifndef SYNTHESIS
`ifndef NO_INIT_MEM_VAL_TASKS
task do_write; //(wa, we, di);
   input  [4:0] wa;
   input   we;
   input  [3:0] di;
   reg    [3:0] d;
   begin
      d = probe_mem_val(wa);
      d = (we ? di : d);
      init_mem_val(wa,d);
   end
endtask

`endif
`endif


`ifndef SYNTHESIS
`ifndef NO_INIT_MEM_VAL_TASKS

`ifndef MEM_REG_NAME 
 `define MEM_REG_NAME MX.mem
`endif

function [3:0] probe_mem_val;
input [4:0] row;
reg [3:0] data;
begin

// probing Flop_Array
if (row == 0) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row0;
if (row == 1) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row1;
if (row == 2) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row2;
if (row == 3) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row3;
if (row == 4) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row4;
if (row == 5) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row5;
if (row == 6) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row6;
if (row == 7) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row7;
if (row == 8) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row8;
if (row == 9) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row9;
if (row == 10) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row10;
if (row == 11) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row11;
if (row == 12) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row12;
if (row == 13) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row13;
if (row == 14) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row14;
if (row == 15) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row15;
if (row == 16) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row16;
if (row == 17) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row17;
if (row == 18) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row18;
if (row == 19) data[3:0] = r_nv_ram_rwsthp_20x4.FlopArray_row19;
    probe_mem_val = data;

end
endfunction
`endif
`endif

`ifndef SYNTHESIS
`ifndef NO_CLEAR_MEM_TASK
`ifndef NO_INIT_MEM_VAL_TASKS
reg disable_clear_mem = 0;
task clear_mem;
integer i;
begin
  if (!disable_clear_mem) 
  begin
    for (i = 0; i < 20; i = i + 1)
      begin
        init_mem_val(i, 'bx);
      end
    init_mem_commit();
  end
end
endtask
`endif
`endif
`endif

`ifndef SYNTHESIS
`ifndef NO_INIT_MEM_ZERO_TASK
`ifndef NO_INIT_MEM_VAL_TASKS
task init_mem_zero;
integer i;
begin
 for (i = 0; i < 20; i = i + 1)
   begin
     init_mem_val(i, 'b0);
   end
 init_mem_commit();
end
endtask
`endif
`endif
`endif

`ifndef SYNTHESIS
`ifndef NO_INIT_MEM_VAL_TASKS
`ifndef NO_INIT_MEM_FROM_FILE_TASK
task init_mem_from_file;
input string init_file;
integer i;
begin

 $readmemh(init_file,shadow_mem);
 for (i = 0; i < 20; i = i + 1)
   begin

     shadow_written[i] = 1'b1;

   end
 init_mem_commit();

end
endtask
`endif
`endif
`endif

`ifndef SYNTHESIS
`ifndef NO_INIT_MEM_RANDOM_TASK
`ifndef NO_INIT_MEM_VAL_TASKS
RANDFUNC rf0 ();

task init_mem_random;
reg [3:0] random_num;
integer i;
begin
 for (i = 0; i < 20; i = i + 1)
   begin
     random_num = {rf0.rollpli(0,32'hffffffff)};
     init_mem_val(i, random_num);
   end
 init_mem_commit();
end
endtask
`endif
`endif
`endif

`ifndef SYNTHESIS
`ifndef NO_FLIP_TASKS
`ifndef NO_INIT_MEM_VAL_TASKS

RANDFUNC rflip ();

task random_flip;
integer random_num;
integer row;
integer bitnum;
begin
  random_num = rflip.rollpli(0, 80);
  row = random_num / 4;
  bitnum = random_num % 4;
  target_flip(row, bitnum);
end
endtask

task target_flip;
input [4:0] row;
input [3:0] bitnum;
reg [3:0] data;
begin
  if(!$test$plusargs("no_display_target_flips"))
    $display("%m: flipping row %d bit %d at time %t", row, bitnum, $time);

  data = probe_mem_val(row);
  data[bitnum] = ~data[bitnum];
  init_mem_val(row, data);
  init_mem_commit();
end
endtask

`endif
`endif
`endif

// The main module is done
endmodule

//********************************************************************************

