<html><head><title>UVMC Command API Example - Phase Control</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="UVMC_Command_API_Example-Phase_Control" href="../../../uvmc/examples/commands/ex_phase_control.cpp">UVMC Command API Example - Phase Control</a></h1><div class=CBody><p>This code provides an example of waiting for each UVM phase to reach a specified state and then, if the phase is a task phase, controlling its progression by raising and dropping the objection that governs it.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>uvmc_wait_for_phase</td><td class=CDLDescription>block until UVM has reached a certain phase.&nbsp; You may also wait for certain phase state (e.g. started, ended, etc.)</td></tr><tr><td class=CDLEntry>uvmc_raise_objection</td><td class=CDLDescription>prevent a UVM phase from ending</td></tr><tr><td class=CDLEntry>uvmc_drop_objection</td><td class=CDLDescription>remove your objection to ending a UVM phase</td></tr></table><p>See the <a href="../../src/connect/sc/uvmc_commands-h.html#Phasing" class=LGroup id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Phasing</a> command descriptions for more details.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#UVMC_Command_API_Example-Phase_Control" >UVMC Command API Example - Phase Control</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This code provides an example of waiting for each UVM phase to reach a specified state and then, if the phase is a task phase, controlling its progression by raising and dropping the objection that governs it.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="top" href="../../../uvmc/examples/commands/ex_phase_control.cpp">top</a></h2><div class=CBody><p>Our top-level SC module does the following</p><ul><li>Creates an instance of a generic <a href="../../examples_ovm/converters/consumer-cpp.html#consumer" class=LClass >consumer</a>.&nbsp; The consumer merely prints the transactions it receives side and sends them out its analysis port.</li><li>Spawn a thread function, <i>show_uvm_phasing</i></li><li>Register the consumer&rsquo;s ports for UVMC connection.</li></ul><blockquote><pre>#include &quot;systemc.h&quot;
#include &quot;tlm.h&quot;
#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace sc_core;
using namespace tlm;

#include &quot;uvmc.h&quot;
#include &quot;uvmc_macros.h&quot;
using namespace uvmc;

#include &quot;consumer.cpp&quot;

SC_MODULE(top)
{
  consumer cons;

  SC_CTOR(top) : cons(&quot;consumer&quot;) {
    SC_THREAD(show_uvm_phasing);
    uvmc_connect(cons.in,&quot;foo&quot;);
    uvmc_connect(cons.analysis_out,&quot;bar&quot;);
  }

  void show_uvm_phasing();

  private:
  void spawn_phase_control_proc(const char* phase, bool is_task_phase);
  void wait_phase_started(const char* ph_name, bool is_task_phase);
};</pre></blockquote>

<!--START_ND_SUMMARY index=1-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=1 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#top" >top</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Our top-level SC module does the following</td></tr>
  <!-- index=2 -->

<tr class="SMethod SIndent1 SMarked"><td class=SEntry><a href="#top.show_uvm_phasing" >show_uvm_phasing</a></td><td class=SDescription>The <i>show_uvm_phasing</i> thread spawns as many sub-processes as there are predefined phases in UVM, where each thread will wait for its associated phase. </td></tr>
  <!-- index=3 -->

<tr class="SMethod SIndent1"><td class=SEntry><a href="#top.spawn_phase_control_proc" >spawn_phase_control_proc</a></td><td class=SDescription>A convenience function for spawning a dynamic SC thread.</td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent1 SMarked"><td class=SEntry><a href="#top.wait_phase_started" >wait_phase_started</a></td><td class=SDescription>This function is spawned as a dynamic SC thread for each predefined phase in UVM. </td></tr>
  <!-- index=5 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#top.sc_main" >sc_main</a></td><td class=SDescription>Creates an instance of our <a href="#top" class=LClass id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">top</a> module then calls <i>sc_start</i> to start SC simulation.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=2 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="top.show_uvm_phasing" href="../../../uvmc/examples/commands/ex_phase_control.cpp">show_uvm_phasing</a></h3><div class=CBody><p>The <i>show_uvm_phasing</i> thread spawns as many sub-processes as there are predefined phases in UVM, where each thread will wait for its associated phase.&nbsp; If the phase is a task-based phase, each thread will raise an objection, delay, then drop the objection.&nbsp; This shows how SC can prevent a UVM phase from ending.&nbsp; The <a href="../../examples_ovm/connections/sc2sv-cpp.html#UVMC_Connection_Example-SC_to_SV,SC_side" class=LSection id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">UVMC Connection Example - SC to SV, SC side</a> shows one practical use for phase control.</p><blockquote><pre>void top::show_uvm_phasing()
{
  wait(SC_ZERO_TIME);

  // common phases
  spawn_phase_control_proc(&quot;build&quot;,0);
  spawn_phase_control_proc(&quot;connect&quot;,0);
  spawn_phase_control_proc(&quot;end_of_elaboration&quot;,0);
  spawn_phase_control_proc(&quot;start_of_simulation&quot;,0);
  spawn_phase_control_proc(&quot;run&quot;,1);
  spawn_phase_control_proc(&quot;extract&quot;,0);
  spawn_phase_control_proc(&quot;check&quot;,0);
  spawn_phase_control_proc(&quot;report&quot;,0);

  // uvm run-time phases
  spawn_phase_control_proc(&quot;pre_reset&quot;,1);
  spawn_phase_control_proc(&quot;reset&quot;,1);
  spawn_phase_control_proc(&quot;post_reset&quot;,1);
  spawn_phase_control_proc(&quot;pre_configure&quot;,1);
  spawn_phase_control_proc(&quot;configure&quot;,1);
  spawn_phase_control_proc(&quot;post_configure&quot;,1);
  spawn_phase_control_proc(&quot;pre_main&quot;,1);
  spawn_phase_control_proc(&quot;main&quot;,1);
  spawn_phase_control_proc(&quot;post_main&quot;,1);
  spawn_phase_control_proc(&quot;pre_shutdown&quot;,1);
  spawn_phase_control_proc(&quot;shutdown&quot;,1);
  spawn_phase_control_proc(&quot;post_shutdown&quot;,1);
}</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="top.spawn_phase_control_proc" href="../../../uvmc/examples/commands/ex_phase_control.cpp">spawn_phase_control_proc</a></h3><div class=CBody><p>A convenience function for spawning a dynamic SC thread.</p><blockquote><pre>void top::spawn_phase_control_proc(const char* phase, bool is_task_phase)
{
  sc_spawn(sc_bind(&amp;top::wait_phase_started,this,phase,
         is_task_phase), (string(&quot;wait_for_&quot;) + phase).c_str());
}</pre></blockquote></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="top.wait_phase_started" href="../../../uvmc/examples/commands/ex_phase_control.cpp">wait_phase_started</a></h3><div class=CBody><p>This function is spawned as a dynamic SC thread for each predefined phase in UVM.&nbsp; Each thread waits for the UVM phase given by <i>ph_name</i> to reach the started state.&nbsp; If the phase is a task phase, it will raise an objection, wait 10ns, then drop the objection.&nbsp; The reports that get emitted will show that UVM phases are being controlled by these threads.</p><blockquote><pre>void top::wait_phase_started(const char* ph_name, bool is_task_phase)
{

  UVMC_INFO(&quot;SC_TOP/WAITING&quot;,(string(&quot;Waiting for phase &quot;) +
            ph_name + &quot; to start...&quot;).c_str(),UVM_LOW,&quot;&quot;);

  uvmc_wait_for_phase(ph_name, UVM_PHASE_STARTED);

  UVMC_INFO(&quot;SC_TOP/PH_STARTED&quot;, (string(name()) + &quot;: Phase &quot; +
            ph_name + &quot; has started&quot;).c_str(), UVM_MEDIUM,&quot;&quot;);

  // if a task, raise and drop objection

  if (is_task_phase)
  {
    UVMC_INFO(&quot;SC_TOP/RAISE_OBJ&quot;,
              (string(name()) + &quot; raising objection in phase &quot;
              + ph_name).c_str(), UVM_MEDIUM,&quot;&quot;);

    // if we're the 'run' phase, wait until post_shutdown phase
    if (!strcmp(ph_name ,&quot;run&quot;))
      uvmc_wait_for_phase(&quot;post_shutdown&quot;,UVM_PHASE_STARTED);

    uvmc_raise_objection(ph_name, name(), &quot;SC waiting 10ns&quot;);

    // wait some delay to prove we are in control...
    wait(sc_time(10,SC_NS));

    UVMC_INFO(&quot;SC_TOP/DROP_OBJ&quot;,
              (string(name()) + &quot; dropping objection in phase &quot;
              + ph_name).c_str(), UVM_MEDIUM,&quot;&quot;);

    uvmc_drop_objection(ph_name, name(), &quot;10ns has passed&quot;);
  }
}</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="top.sc_main" href="../../../uvmc/examples/commands/ex_phase_control.cpp">sc_main</a></h3><div class=CBody><p>Creates an instance of our <a href="#top" class=LClass id=link4 onMouseOver="ShowTip(event, 'tt2', 'link4')" onMouseOut="HideTip('tt2')">top</a> module then calls <i>sc_start</i> to start SC simulation.</p><blockquote><pre>int sc_main(int argc, char* argv[])
{
  top t(&quot;top&quot;);
  sc_start();
  return 0;
}</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CGroup>An API that provides access UVM&rsquo;s phase state and the objection objects used to control phase progression.</div></div><div class=CToolTip id="tt2"><div class=CClass>Our top-level SC module does the following</div></div><div class=CToolTip id="tt3"><div class=CSection>This example shows a SC producer driving a SV consumer via a TLM connection made with UVMC, including how to derive a SC producer subtype that can control UVM phasing using the UVMC Command API. </div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>