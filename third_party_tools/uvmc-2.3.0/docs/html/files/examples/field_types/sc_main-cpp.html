<html><head><title>SC Type Support</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="SC_Type_Support" href="../../../uvmc/examples/field_types/sc_main.cpp">SC Type Support</a></h1><div class=CBody><p>This example defines and uses a transaction that declares as members each of the data types supported for cross-language transfer by UVMC.&nbsp; The example consists of the following classes and functions:</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Contents</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td class=SEntry><a href="#SC_Type_Support" >SC Type Support</a></td><td class=SDescription>This example defines and uses a transaction that declares as members each of the data types supported for cross-language transfer by UVMC. </td></tr>
  <!-- index=1 -->

<tr class="SSMethod SMarked"><td class=SEntry><a href="#Packet" >Packet</a></td><td class=SDescription>First, we define a transaction class, <i>Packet</i>, declaring an instance of each supported data type for UVMC transfer. </td></tr>
  <!-- index=2 -->

<tr class="SSMethod"><td class=SEntry><a href="#uvmc_converterPacket" >uvmc_converter&lt;Packet&gt;</a></td><td class=SDescription>Next, we defined a template specialization of uvmc_converter&lt;T&gt; for our <a href="#Packet" class=LClass id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Packet</a> type. </td></tr>
  <!-- index=6 -->

<tr class="SSMethod SMarked"><td class=SEntry><a href="#uvmc_printPacket" >uvmc_print&lt;Packet&gt;</a></td><td class=SDescription>A template specialization of uvmc_print&lt;T&gt;, this class is used by <a href="#operator(ostream,Packet)" class=LClass id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">operator&lt;&lt;(ostream,Packet)</a> to print the contents of a <a href="#Packet" class=LClass id=link3 onMouseOver="ShowTip(event, 'tt1', 'link3')" onMouseOut="HideTip('tt1')">Packet</a>.</td></tr>
  <!-- index=10 -->

<tr class="SSMethod"><td class=SEntry><a href="#operator(ostream,Packet)" >operator&lt;&lt;(ostream,Packet)</a></td><td class=SDescription>We next defines <i>operator&lt;&lt; (ostream&amp;)</i> for <a href="#Packet" class=LClass id=link4 onMouseOver="ShowTip(event, 'tt1', 'link4')" onMouseOut="HideTip('tt1')">Packet</a> types, enabling us to output Packet objects to cout and other output streams. </td></tr>
  <!-- index=11 -->

<tr class="SSMethod SMarked"><td class=SEntry><a href="#Consumer" >Consumer</a></td><td class=SDescription>Defines a simple consumer of <a href="#Packet" class=LClass id=link5 onMouseOver="ShowTip(event, 'tt1', 'link5')" onMouseOut="HideTip('tt1')">Packets</a>. </td></tr>
  <!-- index=12 -->

<tr class="SSMethod"><td class=SEntry><a href="#sc_main" >sc_main</a></td><td class=SDescription>Finally, in <i>sc_main</i>, we simply instantiate a <a href="#Consumer" class=LClass id=link6 onMouseOver="ShowTip(event, 'tt3', 'link6')" onMouseOut="HideTip('tt3')">Consumer</a> of <a href="#Packet" class=LClass id=link7 onMouseOver="ShowTip(event, 'tt1', 'link7')" onMouseOut="HideTip('tt1')">Packets</a>, register tUVMC connections to its <i>in</i> export and <i>analysis_out</i> port, then start SC simulation. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="Packet" href="../../../uvmc/examples/field_types/sc_main.cpp">Packet</a></h2><div class=CBody><p>First, we define a transaction class, <i>Packet</i>, declaring an instance of each supported data type for UVMC transfer.&nbsp; It contains the following fields:</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>integrals</td><td class=CDLDescription>bool, char, short, int, long long, and their unsigned counterparts.</td></tr><tr><td class=CDLEntry>enum</td><td class=CDLDescription>user-defined enumeration types packed by their numeric value.&nbsp; A compatible enumeration type must be defined on the SV side.</td></tr><tr><td class=CDLEntry>reals</td><td class=CDLDescription>float and double translate to shortreal and real, respectively.</td></tr><tr><td class=CDLEntry>strings</td><td class=CDLDescription>terminated with the NULL character.&nbsp; Use vector&lt;char&gt; for an array of bytes whose elements can include the &lsquo;0&rsquo; value</td></tr><tr><td class=CDLEntry>arrays</td><td class=CDLDescription>fixed arrays, and STL vector&lt;T&gt;, list&lt;T&gt;, and map&lt;KEY,T&gt; are supported as long as T and KEY are also supported.&nbsp; These types are similar to the SV queue, dynamic array, and associate array types, respectively.&nbsp; Be sure to #include the definitions and declare you&rsquo;re &lsquo;using&rsquo; any STL types in your transaction.</td></tr><tr><td class=CDLEntry>time</td><td class=CDLDescription>packed as 64-bit values.&nbsp; Equates to the SV &lsquo;time&rsquo; type.</td></tr><tr><td class=CDLEntry>sc data types</td><td class=CDLDescription>sc_bit, sc_logic, sc_bv&lt;N&gt;, sc_lv&lt;N&gt;, sc_int&lt;N&gt;, sc_uint&lt;N&gt;, sc_bigint&lt;N&gt;, and sc_biguint&lt;N&gt;, for any valid width, N. These translate to bit and logic vectors on the SV side.</td></tr></table><p>Here is the complete definition of our SC-side Packet class.&nbsp; Note that it does not inherit from any base class.</p><blockquote><pre>class Packet {

  public:
    enum cmds_t { ADD, SUBTRACT, MULTIPLY, DIVIDE };

    cmds_t             enum32;  // Enumerations

    long long          int64;   // Signed integrals
    int                int32;
    short              int16;
    char               int8;
    bool               int1;

    unsigned long long uint64;  // Unsigned integrals
    unsigned int       uint32;
    unsigned short     uint16;
    unsigned char      uint8;
    bool               uint1;

    double             real64;

    sc_time            time64;  // Time

    string             str;     // Strings

    int                arr[3];  // Arrays
    vector&lt;char&gt;       q;
    list&lt;short&gt;        da;
    map&lt;short,short&gt;   aa;

    sub_object         obj;     // Sub-objects

    sc_bit             scbit;   // SystemC data types
    sc_logic           sclogic;
    sc_bv&lt;17&gt;          scbv;
    sc_lv&lt;35&gt;          sclv;
    sc_int&lt;6&gt;          scint;
    sc_uint&lt;25&gt;        scuint;
    sc_bigint&lt;37&gt;      scbigint;
    sc_biguint&lt;62&gt;     scbiguint;
};</pre></blockquote>

<!--START_ND_SUMMARY index=1-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=1 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#Packet" >Packet</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>First, we define a transaction class, <i>Packet</i>, declaring an instance of each supported data type for UVMC transfer. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=2 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="uvmc_converterPacket" href="../../../uvmc/examples/field_types/sc_main.cpp">uvmc_converter&lt;Packet&gt;</a></h2><div class=CBody><p>Next, we defined a template specialization of uvmc_converter&lt;T&gt; for our <a href="#Packet" class=LClass id=link10 onMouseOver="ShowTip(event, 'tt1', 'link10')" onMouseOut="HideTip('tt1')">Packet</a> type.&nbsp; This class defines <a href="#uvmc_converterPacket.do_pack" class=LMethod id=link11 onMouseOver="ShowTip(event, 'tt4', 'link11')" onMouseOut="HideTip('tt4')">do_pack</a> and <a href="#uvmc_converterPacket.do_unpack" class=LMethod id=link12 onMouseOver="ShowTip(event, 'tt5', 'link12')" onMouseOut="HideTip('tt5')">do_unpack</a> methods that convert our <a href="#Packet" class=LClass id=link13 onMouseOver="ShowTip(event, 'tt1', 'link13')" onMouseOut="HideTip('tt1')">Packet</a> using the <i>uvmc_packer</i> object passed as an argument.&nbsp; Unlike in SV, we are defining packing and unpacking functionality in a separate class and not as methods of the <a href="#Packet" class=LClass id=link14 onMouseOver="ShowTip(event, 'tt1', 'link14')" onMouseOut="HideTip('tt1')">Packet</a> itself.&nbsp; This allows us to define custom packing algorithms, or &ldquo;policies&rdquo;, without having to subtype the Packet class.</p>

<!--START_ND_SUMMARY index=2-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=2 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#uvmc_converterPacket" >uvmc_converter&lt;Packet&gt;</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Next, we defined a template specialization of uvmc_converter&lt;T&gt; for our <a href="#Packet" class=LClass id=link8 onMouseOver="ShowTip(event, 'tt1', 'link8')" onMouseOut="HideTip('tt1')">Packet</a> type. </td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvmc_converterPacket.Methods" >Methods</a></td><td class=SDescription></td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvmc_converterPacket.do_pack" >do_pack</a></td><td class=SDescription>Serializes the packet <i>t</i> using the provided <i>uvmc_packer</i> argument, <i>packer</i>.</td></tr>
  <!-- index=5 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvmc_converterPacket.do_unpack" >do_unpack</a></td><td class=SDescription>Extracts a serialized version of a packet into the given <a href="#Packet" class=LClass id=link9 onMouseOver="ShowTip(event, 'tt1', 'link9')" onMouseOut="HideTip('tt1')">Packet</a> object. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvmc_converterPacket.Methods" href="../../../uvmc/examples/field_types/sc_main.cpp">Methods</a></h3></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvmc_converterPacket.do_pack" href="../../../uvmc/examples/field_types/sc_main.cpp">do_pack</a></h3><div class=CBody><p>Serializes the packet <i>t</i> using the provided <i>uvmc_packer</i> argument, <i>packer</i>.</p><p><i>All fields are &ldquo;streamed&rdquo; into the packer object using operator&lt;&lt;, which the packer defines for each of of the supported data types.</i></p><p>In effect, we are packing our object just as you might print your object contents to <i>cout</i>.&nbsp; Instead of streaming to <i>cout</i>, you are streaming to the <i>packer</i>.&nbsp; Thus the process of packing an object is easy.&nbsp; You need only ensure that the field order of packing and unpacking are the same for the converters on both sides of the language boundary.</p><p>The resulting bits are retained by the <i>packer</i> for subsequent extraction and transfer to SV.</p><p>The bits representing the serialized transaction will be transferred to SV, preloaded into a SV packer object, then unpacked via a compatible <i>unpack</i> operation in SV.</p><p>This example packs all members with one statement.&nbsp; You may need to split into several statements, e.g.&nbsp;  when conditionally packing sub-objects.</p><p>When packing sub-objects, you must first pack a 4-bit value as follows</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>0</td><td class=CDLDescription>if the sub-object is NULL or is not to be packed</td></tr><tr><td class=CDLEntry>1</td><td class=CDLDescription>if the sub-object is non-NULL and packed.</td></tr></table><p>If you pack a &lsquo;1&rsquo; as above, then pack the sub-object by calling</p><blockquote><pre>uvmc_conveter&lt;obj type&gt;::do_pack(packer);
    static void do_pack(const Packet &amp;t, uvmc_packer &amp;packer)
    {
      packer
        &lt;&lt; t.enum32
        &lt;&lt; t.int64  &lt;&lt; t.int32   &lt;&lt; t.int16  &lt;&lt; t.int8  &lt;&lt; t.int1
        &lt;&lt; t.uint64 &lt;&lt; t.uint32  &lt;&lt; t.uint16 &lt;&lt; t.uint8 &lt;&lt; t.uint1
        &lt;&lt; t.scbit  &lt;&lt; t.sclogic &lt;&lt; t.scbv   &lt;&lt; t.sclv
        &lt;&lt; t.scint  &lt;&lt; t.scuint  &lt;&lt; t.scbigint &lt;&lt; t.scbiguint
        &lt;&lt; t.time64 &lt;&lt; t.real64
        &lt;&lt; t.str &lt;&lt; t.arr &lt;&lt; t.q &lt;&lt; t.da &lt;&lt; t.aa;

      // pack object:
      packer &lt;&lt; (sc_bv&lt;4&gt;(1));
      uvmc_converter&lt;sub_object&gt;::do_pack(t.obj, packer);

    }</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvmc_converterPacket.do_unpack" href="../../../uvmc/examples/field_types/sc_main.cpp">do_unpack</a></h3><div class=CBody><p>Extracts a serialized version of a packet into the given <a href="#Packet" class=LClass id=link15 onMouseOver="ShowTip(event, 'tt1', 'link15')" onMouseOut="HideTip('tt1')">Packet</a> object.&nbsp; The bits representing the serialized transaction have been packed via a compatible <i>do_pack</i> operation, transferred across the language boundary if necessary, then preloaded into the <i>packer</i> object before this function is called.</p><p><i>All fields are &ldquo;streamed&rdquo; out of the packer object using operator&gt;&gt;, which the packer defines for each of of the supported data types.</i></p><p>In effect, we are unpacking into a Packet object just as you might stream Packet contents from <i>cin</i>.&nbsp; Instead of streaming from <i>cin</i>, you are streaming from the <i>packer</i>.&nbsp; Thus, the process of unpacking into an object is easy.&nbsp; You need only ensure that the field order of packing and unpacking are the same for the converters on both sides of the language boundary.</p><p>When unpacking sub-objects, you first unpack a 4-bit value and interpret as follows</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>0</td><td class=CDLDescription>set the sub-object to NULL</td></tr><tr><td class=CDLEntry>1</td><td class=CDLDescription>unpack the sub-object by calling <i>uvmc_conveter&lt;type&gt;::do_unpack</i></td></tr></table><p>This example unpacks all members with one statement.&nbsp; You may need to split into several statements, e.g.&nbsp;  when conditionally unpacking sub-objects.</p><blockquote><pre>    static void do_unpack(Packet &amp;t, uvmc_packer &amp;packer)
    {
      packer
        &gt;&gt; t.enum32
        &gt;&gt; t.int64  &gt;&gt; t.int32   &gt;&gt; t.int16  &gt;&gt; t.int8  &gt;&gt; t.int1
        &gt;&gt; t.uint64 &gt;&gt; t.uint32  &gt;&gt; t.uint16 &gt;&gt; t.uint8 &gt;&gt; t.uint1
        &gt;&gt; t.scbit  &gt;&gt; t.sclogic &gt;&gt; t.scbv   &gt;&gt; t.sclv
        &gt;&gt; t.scint  &gt;&gt; t.scuint  &gt;&gt; t.scbigint &gt;&gt; t.scbiguint
        &gt;&gt; t.time64 &gt;&gt; t.real64
        &gt;&gt; t.str &gt;&gt; t.arr &gt;&gt; t.q &gt;&gt; t.da &gt;&gt; t.aa;

      sc_bv&lt;4&gt; is_null;
      packer &gt;&gt; is_null;
      if (is_null != 0)
        uvmc_converter&lt;sub_object&gt;::do_unpack(t.obj, packer);

    }

}; // uvmc_conveter&lt;Packet&gt;</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="uvmc_printPacket" href="../../../uvmc/examples/field_types/sc_main.cpp">uvmc_print&lt;Packet&gt;</a></h2><div class=CBody><p>A template specialization of uvmc_print&lt;T&gt;, this class is used by <a href="#operator(ostream,Packet)" class=LClass id=link19 onMouseOver="ShowTip(event, 'tt2', 'link19')" onMouseOut="HideTip('tt2')">operator&lt;&lt;(ostream,Packet)</a> to print the contents of a <a href="#Packet" class=LClass id=link20 onMouseOver="ShowTip(event, 'tt1', 'link20')" onMouseOut="HideTip('tt1')">Packet</a>.</p><p>The <a href="#uvmc_printPacket.print" class=LMethod id=link21 onMouseOver="ShowTip(event, 'tt6', 'link21')" onMouseOut="HideTip('tt6')">print</a> method is the entry point; it calls <a href="#uvmc_printPacket.do_print" class=LMethod id=link22 onMouseOver="ShowTip(event, 'tt7', 'link22')" onMouseOut="HideTip('tt7')">do_print</a>, which performs the actual streaming.</p><p>An overload of non-member function, <i>operator&lt;&lt;</i>, for the <i>ostream</i> is defined for <a href="#Packet" class=LClass id=link23 onMouseOver="ShowTip(event, 'tt1', 'link23')" onMouseOut="HideTip('tt1')">Packet</a> types.&nbsp; Its implementation calls this class&rsquo; <a href="#uvmc_printPacket.print" class=LMethod id=link24 onMouseOver="ShowTip(event, 'tt6', 'link24')" onMouseOut="HideTip('tt6')">print</a> method.</p><p>With these defined, any <a href="#Packet" class=LClass id=link25 onMouseOver="ShowTip(event, 'tt1', 'link25')" onMouseOut="HideTip('tt1')">Packet</a> object can be output as follows</p><blockquote><pre>#include &lt;iostream&gt;
using std::ostream;
using std::cout;

Packet t;
...
cout &lt;&lt; t &lt;&lt; endl;</pre></blockquote>

<!--START_ND_SUMMARY index=6-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=6 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#uvmc_printPacket" >uvmc_print&lt;Packet&gt;</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>A template specialization of uvmc_print&lt;T&gt;, this class is used by <a href="#operator(ostream,Packet)" class=LClass id=link16 onMouseOver="ShowTip(event, 'tt2', 'link16')" onMouseOut="HideTip('tt2')">operator&lt;&lt;(ostream,Packet)</a> to print the contents of a <a href="#Packet" class=LClass id=link17 onMouseOver="ShowTip(event, 'tt1', 'link17')" onMouseOut="HideTip('tt1')">Packet</a>.</td></tr>
  <!-- index=7 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvmc_printPacket.Methods" >Methods</a></td><td class=SDescription></td></tr>
  <!-- index=8 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvmc_printPacket.do_print" >do_print</a></td><td class=SDescription>Streams the data members of the <a href="#Packet" class=LClass id=link18 onMouseOver="ShowTip(event, 'tt1', 'link18')" onMouseOut="HideTip('tt1')">Packet</a> object <i>t</i> to the provided output stream <i>os</i>, which defaults to the standard output stream, <i>cout</i>.</td></tr>
  <!-- index=9 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvmc_printPacket.print" >print</a></td><td class=SDescription>The entry point for printing our Packet. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=7 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvmc_printPacket.Methods" href="../../../uvmc/examples/field_types/sc_main.cpp">Methods</a></h3></div></div>




 <!--CONTENT index=8 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvmc_printPacket.do_print" href="../../../uvmc/examples/field_types/sc_main.cpp">do_print</a></h3><div class=CBody><p>Streams the data members of the <a href="#Packet" class=LClass id=link26 onMouseOver="ShowTip(event, 'tt1', 'link26')" onMouseOut="HideTip('tt1')">Packet</a> object <i>t</i> to the provided output stream <i>os</i>, which defaults to the standard output stream, <i>cout</i>.</p><p>All data members, including sub-objects, must have <i>operator&lt;&lt;(ostream&amp;)</i> defined.&nbsp; This is true for all C++ and SC built-in types.&nbsp; The UVMC library provides <i>operator&lt;&lt;(ostream&amp;)</i> for the STL <i>vector&lt;T&gt;</i>, <i>list&lt;T&gt;</i>, and <i>map&lt;KEY,T&gt;</i> types.</p><p>Infinite recursion through self-reference is not caught.&nbsp; You are responsible for making sure sub-objects, if streamed, do not refer to an object already streamed.</p><p>Although example streams all members with one statement, you may split the task into as many statements as you like.</p><blockquote><pre>template &lt;&gt;
class uvmc_print&lt;Packet&gt; {
  public:

  static void do_print(const Packet&amp; t, ostream&amp; os=cout) {
        os &lt;&lt; &quot; enum32:&quot; &lt;&lt; t.enum32
           &lt;&lt; &quot; int64:&quot;  &lt;&lt; t.int64
           &lt;&lt; &quot; int32:&quot;  &lt;&lt; t.int32
           &lt;&lt; &quot; int16:&quot;  &lt;&lt; t.int16
           &lt;&lt; &quot; int8:&quot;   &lt;&lt; t.int8
           &lt;&lt; &quot; int1:&quot;   &lt;&lt; t.int1
           &lt;&lt; &quot; int64:&quot;  &lt;&lt; t.uint64
           &lt;&lt; &quot; int32:&quot;  &lt;&lt; t.uint32
           &lt;&lt; &quot; int16:&quot;  &lt;&lt; t.uint16
           &lt;&lt; &quot; int8:&quot;   &lt;&lt; t.uint8
           &lt;&lt; &quot; int1:&quot;   &lt;&lt; t.uint1
           &lt;&lt; &quot; scbit:&quot;  &lt;&lt; t.scbit
           &lt;&lt; &quot; sclogic:&quot;&lt;&lt; t.sclogic
           &lt;&lt; &quot; scbv:&quot;   &lt;&lt; t.scbv
           &lt;&lt; &quot; sclv:&quot;   &lt;&lt; t.sclv
           &lt;&lt; &quot; scint:&quot;  &lt;&lt; t.scint
           &lt;&lt; &quot; scuint:&quot;    &lt;&lt; t.scuint
           &lt;&lt; &quot; scbigint:&quot;  &lt;&lt; t.scbigint
           &lt;&lt; &quot; scbiguint:&quot; &lt;&lt; t.scbiguint
           &lt;&lt; &quot; time64:&quot; &lt;&lt; t.time64
           &lt;&lt; &quot; real64:&quot; &lt;&lt; t.real64
           &lt;&lt; &quot; str:&quot;    &lt;&lt; t.str
           &lt;&lt; &quot; arr:&quot;    &lt;&lt; t.arr
           &lt;&lt; &quot; q:&quot;      &lt;&lt; t.q
           &lt;&lt; &quot; da:&quot;     &lt;&lt; t.da
           &lt;&lt; &quot; aa:&quot;     &lt;&lt; t.aa
           &lt;&lt; &quot; obj:&quot;    &lt;&lt; t.obj;
  }</pre></blockquote></div></div></div>




 <!--CONTENT index=9 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvmc_printPacket.print" href="../../../uvmc/examples/field_types/sc_main.cpp">print</a></h3><div class=CBody><p>The entry point for printing our Packet.&nbsp; We output a brace, {, then call <a href="#uvmc_printPacket.do_print" class=LMethod id=link27 onMouseOver="ShowTip(event, 'tt7', 'link27')" onMouseOut="HideTip('tt7')">do_print</a>, then output a closing brace, }.&nbsp; This structure prevents superfluous braces for transactions inheriting from base classes with fields.&nbsp; See the Converters examples set to see examples of converters and printers for transactions with base classes.</p><blockquote><pre>  static void print(const Packet&amp; t, ostream&amp; os=cout) {
    os &lt;&lt; &quot;'{&quot;;
    do_print(t,os);
    os &lt;&lt; &quot; }&quot;;
  }

};</pre></blockquote></div></div></div>




 <!--CONTENT index=10 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="operator(ostream,Packet)" href="../../../uvmc/examples/field_types/sc_main.cpp">operator&lt;&lt;(ostream,Packet)</a></h2><div class=CBody><p>We next defines <i>operator&lt;&lt; (ostream&amp;)</i> for <a href="#Packet" class=LClass id=link29 onMouseOver="ShowTip(event, 'tt1', 'link29')" onMouseOut="HideTip('tt1')">Packet</a> types, enabling us to output Packet objects to cout and other output streams.&nbsp; Our <a href="#Consumer" class=LClass id=link30 onMouseOver="ShowTip(event, 'tt3', 'link30')" onMouseOut="HideTip('tt3')">Consumer</a> uses <i>operator&lt;&lt;</i> to output Packets it receives.</p><p>Example usage</p><blockquote><pre>#include &lt;iostream&gt;
using std::ostream;
using std::cout;

Packet t;
...
cout &lt;&lt; t &lt;&lt; endl;
ostream&amp; operator &lt;&lt; (ostream&amp; os, const Packet&amp; v) {
  uvmc_print&lt;Packet&gt;::print(v,os);
}</pre></blockquote>

<!--START_ND_SUMMARY index=10-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=10 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#operator(ostream,Packet)" >operator&lt;&lt;(ostream,Packet)</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>We next defines <i>operator&lt;&lt; (ostream&amp;)</i> for <a href="#Packet" class=LClass id=link28 onMouseOver="ShowTip(event, 'tt1', 'link28')" onMouseOut="HideTip('tt1')">Packet</a> types, enabling us to output Packet objects to cout and other output streams. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=11 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="Consumer" href="../../../uvmc/examples/field_types/sc_main.cpp">Consumer</a></h2><div class=CBody><p>Defines a simple consumer of <a href="#Packet" class=LClass id=link32 onMouseOver="ShowTip(event, 'tt1', 'link32')" onMouseOut="HideTip('tt1')">Packets</a>.&nbsp; Each packet it gets is printed and sent out its <i>analysis_out</i> port.</p><blockquote><pre>using namespace sc_core;
using namespace tlm;

class Consumer : public sc_module,
                 public tlm_blocking_put_if&lt;Packet&gt; {

  public:
  sc_export&lt;tlm_blocking_put_if&lt;Packet&gt; &gt; in;

  tlm_analysis_port&lt;Packet&gt; analysis_out;

  Consumer(sc_module_name nm) : in(&quot;in&quot;),
                                analysis_out(&quot;analysis_out&quot;)
  {
    in(*this);
  }

  virtual void put(const Packet &amp;t) {

    cout &lt;&lt; sc_time_stamp()
         &lt;&lt; &quot; SC consumer executing packet:&quot; &lt;&lt; endl
         &lt;&lt; &quot;  &quot; &lt;&lt; t &lt;&lt; endl;

    wait(123,SC_NS);

    analysis_out.write(t);
  }
};</pre></blockquote>

<!--START_ND_SUMMARY index=11-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=11 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#Consumer" >Consumer</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Defines a simple consumer of <a href="#Packet" class=LClass id=link31 onMouseOver="ShowTip(event, 'tt1', 'link31')" onMouseOut="HideTip('tt1')">Packets</a>. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=12 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="sc_main" href="../../../uvmc/examples/field_types/sc_main.cpp">sc_main</a></h2><div class=CBody><p>Finally, in <i>sc_main</i>, we simply instantiate a <a href="#Consumer" class=LClass id=link35 onMouseOver="ShowTip(event, 'tt3', 'link35')" onMouseOut="HideTip('tt3')">Consumer</a> of <a href="#Packet" class=LClass id=link36 onMouseOver="ShowTip(event, 'tt1', 'link36')" onMouseOut="HideTip('tt1')">Packets</a>, register tUVMC connections to its <i>in</i> export and <i>analysis_out</i> port, then start SC simulation.&nbsp; A SV-side producer will drive this consumer with transactions once SV&rsquo;s reaches its <i>run_phase</i>.</p><blockquote><pre>int sc_main(int argc, char* argv[])
{
  Consumer cons(&quot;consumer&quot;);

  uvmc_connect(cons.in,&quot;foo&quot;);
  uvmc_connect(cons.analysis_out,&quot;bar&quot;);

  sc_start();
  return 0;
}</pre></blockquote>

<!--START_ND_SUMMARY index=12-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=12 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#sc_main" >sc_main</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Finally, in <i>sc_main</i>, we simply instantiate a <a href="#Consumer" class=LClass id=link33 onMouseOver="ShowTip(event, 'tt3', 'link33')" onMouseOut="HideTip('tt3')">Consumer</a> of <a href="#Packet" class=LClass id=link34 onMouseOver="ShowTip(event, 'tt1', 'link34')" onMouseOut="HideTip('tt1')">Packets</a>, register tUVMC connections to its <i>in</i> export and <i>analysis_out</i> port, then start SC simulation. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>First, we define a transaction class, <i>Packet</i>, declaring an instance of each supported data type for UVMC transfer. </div></div><div class=CToolTip id="tt2"><div class=CClass>We next defines <i>operator&lt;&lt; (ostream&amp;)</i> for Packet types, enabling us to output Packet objects to cout and other output streams. </div></div><div class=CToolTip id="tt3"><div class=CClass>Defines a simple consumer of Packets. </div></div><div class=CToolTip id="tt4"><div class=CMethod>Serializes the packet <i>t</i> using the provided <i>uvmc_packer</i> argument, <i>packer</i>.</div></div><div class=CToolTip id="tt5"><div class=CMethod>Extracts a serialized version of a packet into the given Packet object. </div></div><div class=CToolTip id="tt6"><div class=CMethod>The entry point for printing our Packet. </div></div><div class=CToolTip id="tt7"><div class=CMethod>Streams the data members of the Packet object <i>t</i> to the provided output stream <i>os</i>, which defaults to the standard output stream, <i>cout</i>.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>