<html><head><title>Converters</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="Converters" href="../../../uvmc/examples/converters/README.txt">Converters</a></h1><div class=CBody><p>This chapter shows how to write converters for your transactions.&nbsp; Converters facilitate data exchange between components residing in different languages.</p><p>If components were written in a common language, you could guarantee they exchanged compatible data simply by requiring they use the same transaction type.&nbsp; Such components are <i>strongly typed</i>.&nbsp; Any mismatch in type would be caught by the compiler.</p><p>Now let&rsquo;s say two components were developed such that each agreed more or less on the content of the transaction, but this time their transaction definitions were of different types.&nbsp; This condition always the case between components written in two different languages--they cannot possibly share a common transaction definition.&nbsp; To get such components talking to each other requires an adapter, or converter, that translates between the transaction types defined in each language.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#Converters" >Converters</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This chapter shows how to write converters for your transactions. </td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Got_Transactions" >Got Transactions?</a></td><td class=SDescription>UVM Connect imposes very few requirements on the transaction types being conveyed between TLM models in SV and SC, a critical requirement for enabling reuse of existing IP. </td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Do_You_Need_a_Converter" >Do You Need a Converter?</a></td><td class=SDescription>If your models exchange non-extended TLM Generic Payload transactions, you do not need to concern yourself with transaction or converter definition. </td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Easy_When_You_Need_Them" >Easy When You Need Them</a></td><td class=SDescription>To enable non-TLM GP object transfer across the SV-SC boundary, you must define converters in both languages; UVMC makes this an easy process.</td></tr>
  <!-- index=4 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#SV_Conversion_options" >SV Conversion options</a></td><td class=SDescription>Here, we enumerate three different ways to define conversion functionality for your transaction type in SV.</td></tr>
  <!-- index=5 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#In-Transaction" >In-Transaction</a></td><td class=SDescription>This approach defines the conversion algorithm in transaction class itself.</td></tr>
  <!-- index=6 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Converter_Class" >Converter Class</a></td><td class=SDescription>For transactions not extending <i>uvm_sequence_item</i>, you can define a separate converter class extending <i>uvmc_converter #(T)</i>. </td></tr>
  <!-- index=7 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Field_Macros" >Field Macros</a></td><td class=SDescription>This approach defines in-transaction conversion via <i>`uvm_field</i> macro invocations.</td></tr>
  <!-- index=8 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#SC_Conversion_Options" >SC Conversion Options</a></td><td class=SDescription>Conversion of the transaction type in SC can be defined in at least four ways.</td></tr>
  <!-- index=9 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Converter_Specialization" >Converter Specialization</a></td><td class=SDescription>Define a separate class for converting your transaction type.</td></tr>
  <!-- index=10 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Converter_Specialization,Macro-Generated" >Converter Specialization, Macro-Generated</a></td><td class=SDescription>Invoke a convenience macro that defines the converter specialization for you.</td></tr>
  <!-- index=11 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#In-Transaction-SC" >In-Transaction - SC</a></td><td class=SDescription>Define <i>do_pack</i> and <i>do_unpack</i> methods in the SC transaction itself.</td></tr>
  <!-- index=12 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Custom_Adaptor" >Custom Adaptor</a></td><td class=SDescription>Define a custom converter for a transaction whose members differ in number, type, size, and declaration order from the corresponding transaction definition in the other language.</td></tr>
  <!-- index=13 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Notes" >Notes</a></td><td class=SDescription></td></tr>
  <!-- index=14 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Type_Support" >Type Support</a></td><td class=SDescription>UVM Connect supports most of the built in types, arrays, and even sub-objects as properties of your transaction class.</td></tr>
  <!-- index=15 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#On(not)using`uvm_field_macros" >On (not) using `uvm_field macros</a></td><td class=SDescription>The <i>`uvm_field</i> macros hurt run-time performance, can make debug more difficult, and can not accomodate custom behaviors, for example, conditional packing based on the value of another field.</td></tr>
  <!-- index=16 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Packing_Algorithm" >Packing Algorithm</a></td><td class=SDescription>To pass an object across the language boundary, UVM Connect first calls <i>converter.do_pack</i>, which serializes the transaction contents to a simple bit-vector-like form. </td></tr>
  <!-- index=17 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Conversion_on_the_return_path" >Conversion on the return path</a></td><td class=SDescription>TLM2 communication is pass-by-reference, which we emulate in UVM Connect by copying back changes to the original transaction object upon return from every interface method call.</td></tr>
  <!-- index=18 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Deletion_on_the_return_path" >Deletion on the return path</a></td><td class=SDescription>TLM2 rules mandate the same transaction object be used until the transaction execution is fully completed. </td></tr>
  <!-- index=19 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Default_Converters" >Default Converters</a></td><td class=SDescription>UVM Connect defines default converters in both SV and SC</td></tr>
  <!-- index=20 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Default_SV_Converter" >Default SV Converter</a></td><td class=SDescription>The default converter on the SV side is designed to work with <i>uvm_object</i>-based UVM transactions. </td></tr>
  <!-- index=21 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Default_SC_Converter" >Default SC Converter</a></td><td class=SDescription>The default converter on the SC side is meant to mirror the default in SV--it delegates to <i>do_pack</i> and <i>do_unpack</i> methods of your transaction type.</td></tr>
  <!-- index=22 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Converter_Parameters_and_Methods" >Converter Parameters and Methods</a></td><td class=SDescription>The following describes the type parameters and methods of the converter class.</td></tr>
  <!-- index=23 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Converter_Examples" >Converter Examples</a></td><td class=SDescription>The directory <i>UVMC_HOME/examples/converters</i>  contains several examples of transaction conversion in both SystemC (SC) and SystemVerilog (SV)</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Got_Transactions" href="../../../uvmc/examples/converters/README.txt">Got Transactions?</a></h3><div class=CBody><p>UVM Connect imposes very few requirements on the transaction types being conveyed between TLM models in SV and SC, a critical requirement for enabling reuse of existing IP.&nbsp; The more restrictions imposed on the transaction type, the more difficult it will be to reuse the models that use them.</p><ul><li>No base classes required.&nbsp; It is not required that a transaction inherit from any base class to facilitate its conversion--in either SV or SC.&nbsp; The converter is ultimately responsible for all aspects of packing and unpacking the transaction object, and it can be implemented separately from the transaction proper.</li><li>No factory registration required.&nbsp; It is not required that the transaction register with a factory--via a <i>`uvm_object_utils</i> macro inside the transaction definition or by any other means.</li><li>It is not required that the transaction provide conversion methods.&nbsp; The default converter used in SV will expect the transaction type to implement the UVM pack/unpack API, but you can specify a different converter for each or every UVMC connection you make.&nbsp; Your converter class may opt to do the conversion directly, or it can delegate to any other entity capable of performing the operation.</li><li>It is not required that the members (properties) of the transaction classes in both languages be of equal number, equivalent type, and declaration order.&nbsp; The converter can adapt disparate transaction definitions at the same time it serializes the data.&nbsp; The following are valid and compatible UVM Connect transaction definitions, assuming a properly coded converter:</li></ul><blockquote><pre>SV                            SC
class C;                          struct C {
  cmd_t cmd;                        long addr;
  shortint unsigned address;        vector&lt;char&gt; data;
  int payload[MAX_LEN];             bool write;
endclass                          };</pre></blockquote><ul><li>In UVM SV, it is required that the transaction class constructor not define any required arguments.&nbsp; It may have arguments, but they all must have default values.&nbsp; The first constructor argument must be ~string name=&rdquo;&rdquo;~.</li></ul></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Do_You_Need_a_Converter" href="../../../uvmc/examples/converters/README.txt">Do You Need a Converter?</a></h3><div class=CBody><p>If your models exchange non-extended TLM Generic Payload transactions, you do not need to concern yourself with transaction or converter definition.&nbsp; TLM GP definitions and converters are provided by the libraries, so you may skip this section.</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Easy_When_You_Need_Them" href="../../../uvmc/examples/converters/README.txt">Easy When You Need Them</a></h3><div class=CBody><p>To enable non-TLM GP object transfer across the SV-SC boundary, you must define converters in both languages; UVMC makes this an easy process.</p><p>Defining a converter involves implementing two functions--<i>do_pack</i> and <i>do_unpack</i>--either inside your transaction definition or in a separate converter class.&nbsp;  Although the means of conversion are similar between SV and SC, differences in these languages capabilities cause differences in conversion.</p><p>The following sections describe several options available to you for writing converters in SV and SC.</p></div></div></div>




 <!--CONTENT index=4 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="SV_Conversion_options" href="../../../uvmc/examples/converters/README.txt">SV Conversion options</a></h3><div class=CBody><p>Here, we enumerate three different ways to define conversion functionality for your transaction type in SV.</p><p>We illustrate each of these options using the following packet definition.</p><h4 class=CHeading>SV Transaction</h4><blockquote><pre>class packet extends uvm_sequence_item;

  typedef enum { WRITE, READ, NOOP } cmd_t;

  `uvm_object_utils(packet)

  rand cmd_t cmd;
  rand int   addr;
  rand byte  data[$];
  ...

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="In-Transaction" href="../../../uvmc/examples/converters/README.txt">In-Transaction</a></h3><div class=CBody><p>This approach defines the conversion algorithm in transaction class itself.</p><img src="../../../images/UVMC_Converters_SV_InTrans.png" width="393" height="128"><p>A transaction in UVM is derives from <i>uvm_sequence_item</i>, which defines the <i>do_pack</i> and <i>do_unpack</i> virtual methods for users to implement the conversion functionality.&nbsp;  This option is the recommended option for SV-based transactions.</p><p>To use this approach, you declare and define overrides for the virtual <i>do_pack</i> and <i>do_unpack</i> methods in your transaction class.</p><blockquote><pre>virtual function void do_pack   (uvmc_packer packer);
virtual function void do_unpack (uvmc_packer packer);</pre></blockquote><p>Most transactions in SV should be defined this way, as it is prescribed by UVM and it works with UVM Connect&rsquo;s SV default converter.&nbsp; See <a href="#Default_Converters" class=LGroup id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Default Converters</a> for details.</p><p>The following SV packet definition implements the <i>do_pack</i> and <i>do_unpack</i> methods using a set of small utility macros included in the UVM.&nbsp; These macros implement the same packing functionality as using the <i>packer</i> API or <i>`uvm_field</i> macros, but are more efficient.&nbsp; See <a href="sv_converter_trans-sv.html#UVMC_Converter_Example-SV_In-Transaction" class=LSection id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">UVMC Converter Example - SV In-Transaction</a> for a complete example of using this approach.</p><blockquote><pre>class packet extends uvm_sequence_item;

  typedef enum { WRITE, READ, NOOP } cmd_t;

  `uvm_object_utils(packet)

  rand cmd_t cmd;
  rand int   addr;
  rand byte  data[$];

  constraint C_data_size { data.size inside {[1:16]}; }

  function new(string name=&quot;&quot;);
    super.new(name);
  endfunction

  virtual function void do_pack(uvm_packer packer);
    super.do_pack(packer);
    `uvm_pack_enum(cmd)
    `uvm_pack_int(addr)
    `uvm_pack_queue(data)
  endfunction

  virtual function void do_unpack(uvm_packer packer);
    super.do_unpack(packer);
    `uvm_unpack_enum(cmd,cmd_t)
    `uvm_unpack_int(addr)
    `uvm_unpack_queue(data)
  endfunction

  ...

endclass</pre></blockquote><p>When implementing the <i>do_pack</i> and <i>do_unpack</i> methods, you may call various methods of the provided <i>packer</i> object, or you can use a set of small, more efficient convenience macros, also provided in UVM.</p><p>The following packs an <i>addr</i> field using each approach.&nbsp; Our example above uses the small-macro approach.</p><blockquote><pre>virtual function void do_pack(uvm_packer packer);

   `uvm_pack_int(addr)  -or-
    packer.pack_field(addr,$bits(addr)); //more overhead

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Converter_Class" href="../../../uvmc/examples/converters/README.txt">Converter Class</a></h3><div class=CBody><p>For transactions not extending <i>uvm_sequence_item</i>, you can define a separate converter class extending <i>uvmc_converter #(T)</i>.&nbsp; You then specify this converter type when calling <a href="../connections/README-txt.html#The_Connect_Function" class=LGroup id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">The Connect Function</a>.</p><img src="../../../images/UVMC_Converters_SV_UserDefined.png" width="252" height="128"><p>The following SV packet definition implements the <i>do_pack</i> and <i>do_pack</i> methods required of any custom converter.&nbsp; The same small macros used in the <a href="#In-Transaction" class=LGeneric id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">In-Transaction</a> approach can be used in this approach.&nbsp; See <a href="../../examples_ovm/converters/sv_converter_class-sv.html#UVMC_Converter_Example-SV_Converter_Class" class=LSection id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">UVMC Converter Example - SV Converter Class</a> for a complete example.</p><blockquote><pre>class convert_packet extends uvmc_converter #(packet);

   static function void do_pack(packet t, uvm_packer packer);
     `uvm_pack_enum(t.cmd)
     `uvm_pack_int(t.addr)
     `uvm_pack_queue(t.data)
   endfunction

   static function void do_unpack(packet t, uvm_packer packer);
     `uvm_unpack_enum(t.cmd,packet::cmd_t)
     `uvm_unpack_int(t.addr)
     `uvm_unpack_queue(t.data)
   endfunction

 endclass</pre></blockquote><p>To use a custom converter for a specific TLM connection, specify its type when making connection using <a href="../connections/README-txt.html#The_Connect_Function" class=LGroup id=link6 onMouseOver="ShowTip(event, 'tt3', 'link6')" onMouseOut="HideTip('tt3')">The Connect Function</a>.</p><blockquote><pre>uvmc_tlm #(packet, convert_packet)::connect( ... );</pre></blockquote></div></div></div>




 <!--CONTENT index=7 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Field_Macros" href="../../../uvmc/examples/converters/README.txt">Field Macros</a></h3><div class=CBody><p>This approach defines in-transaction conversion via <i>`uvm_field</i> macro invocations.</p><img src="../../../images/UVMC_Converters_SV_InTrans.png" width="393" height="128"><p>While this approach also works with UVMC&rsquo;s default converter, it is far less desirable than the first <a href="#In-Transaction" class=LGeneric id=link7 onMouseOver="ShowTip(event, 'tt4', 'link7')" onMouseOut="HideTip('tt4')">In-Transaction</a> option.&nbsp; The <i>`uvm_field</i> macros provide a convenient means of implementing the <i>do</i> methods of <i>uvm_object</i> for most data types, but they have recurring run-time costs and should be avoided, especially if your transaction is slated for widespread reuse, as with VIP-related transactions.</p><p>Beause this approach is also compatible with the default converter UVMC uses, so you will not need to specify the converter type when making connections with <a href="../connections/README-txt.html#The_Connect_Function" class=LGroup id=link8 onMouseOver="ShowTip(event, 'tt3', 'link8')" onMouseOut="HideTip('tt3')">The Connect Function</a>.&nbsp; See <a href="sv_converter_trans_field_macros-sv.html#UVMC_Converter_Example-SV_In-Transaction_via_Field_Macros" class=LSection id=link9 onMouseOver="ShowTip(event, 'tt6', 'link9')" onMouseOut="HideTip('tt6')">UVMC Converter Example - SV In-Transaction via Field Macros</a> for a complete example of using this approach.</p><blockquote><pre>class packet extends uvm_sequence_item;

  rand cmd_t cmd;
  rand int unsigned addr;
  rand byte data[$];

  constraint C_data_size { data.size inside {[1:16]}; }

  `uvm_object_utils_begin(packet)
    `uvm_field_int(cmd,UVM_ALL_ON)
    `uvm_field_int(addr,UVM_ALL_ON)
    `uvm_field_queue_int(data,UVM_ALL_ON)
  `uvm_object_utils_end

  function new(string name=&quot;&quot;);
    super.new(name);
  endfunction

endclass</pre></blockquote><p>While more succinct than our <a href="#In-Transaction" class=LGeneric id=link10 onMouseOver="ShowTip(event, 'tt4', 'link10')" onMouseOut="HideTip('tt4')">In-Transaction</a> recommendation, we prefer optimizing for recurring run-time performance over one-time coding convenience.&nbsp; The macros&rsquo; run-time performance is inferior, which affects every user of your transaction class in every simulation.&nbsp; Even small performance differences can be magnified and significantly affect the upper bound on performance speed-up with accelleration or emulation hardware.&nbsp; And, as stated before, post-macro-expansion yields hundreds more lines of code compared to implementations that do not employ the <i>`uvm_field</i> macros.&nbsp; You may eventually have to wade through this code during your debug sessions.&nbsp; See <a href="http://verificationacademy.com/uvm-ovm/MacroCostBenefit" class=LURL target=_top>http://verificationacademy.com<span class=HB>- </span>/uvm-ovm<span class=HB>- </span>/MacroCostBenefit</a> for more detail on the topic of macro usage in UVM.</p></div></div></div>




 <!--CONTENT index=8 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="SC_Conversion_Options" href="../../../uvmc/examples/converters/README.txt">SC Conversion Options</a></h3><div class=CBody><p>Conversion of the transaction type in SC can be defined in at least four ways.</p><p>We illustrate each of these options using the following packet definition.</p><h4 class=CHeading>SC Transaction</h4><blockquote><pre>class packet {
  public:
  enum cmd_t { WRITE=0, READ, NOOP };
  cmd_t cmd;
  int addr;
  vector&lt;char&gt; data;
};</pre></blockquote><p>This transaction has no base class, no methods for packing or unpacking, no macros, etc.&nbsp; It is a simple container of data representing a bus transaction.</p><p>With SystemC, you are more easily able to decouple the transaction data from the algorithms that operate on the data.&nbsp; The SC transaction and converter definitions are typically in separate classes.&nbsp; Existing transaction definitions in SC can be used in a UVM Connect context by defining converters for them.</p><p>An external converter class requires that all transaction fields be public or have public accessor member functions.&nbsp; The <i>friend</i> construct in C++ lets you circumvent this protection, but it is not recommended.</p></div></div></div>




 <!--CONTENT index=9 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Converter_Specialization" href="../../../uvmc/examples/converters/README.txt">Converter Specialization</a></h3><div class=CBody><p>Define a separate class for converting your transaction type.</p><p>In SC, conversion for a transaction is typically defined in a separate class called a <i>template specialization</i>.&nbsp; C++ allows you to specialize the default converter implementation for a specific transaction type, <i>T</i>.</p><img src="../../../images/UVMC_Converters_SC_UserDefined.png" width="258" height="131"><p>The converter specialization for our <i>packet</i> type can be defined as follows</p><blockquote><pre>#include &quot;uvmc.h&quot;
using namespace uvmc;

template &lt;&gt;
class uvmc_converter&lt;packet&gt; {
  public:
  virtual void do_pack(const packet &amp;t,
                       uvmc_packer &amp;packer) {
    packer &lt;&lt; t.cmd &lt;&lt; t.addr &lt;&lt; t.data;
  }
  virtual void do_unpack(packet &amp;t,
                         uvmc_packer &amp;packer) {
    packer &gt;&gt; t.cmd &gt;&gt; t.addr &gt;&gt; t.data;
  }
};</pre></blockquote><p>When implementing the converter&rsquo;s <i>do_pack</i> and <i>do_unpack</i> functions, you stream your transaction members to and from the <i>packer</i> variable, an instance of <i>uvmc_packer</i> that is inherited from an internal base class.</p><p>To pack, you stream the fields into the <i>packer</i></p><blockquote><pre>packer &lt;&lt; t.cmd &lt;&lt; t.addr &lt;&lt; t.data;</pre></blockquote><p>To unpack, you stream the fields from the <i>packer</i></p><blockquote><pre>packer &gt;&gt; t.cmd &gt;&gt; t.addr &gt;&gt; t.data;</pre></blockquote><p>You can stream all the fields with one statement as shown above, or stream in separate statements, perhaps with some conditional and other code in between.</p><blockquote><pre>packer &lt;&lt; t.cmd;
...
packer &lt;&lt; t.addr;
...
packer &lt;&lt; t.data;</pre></blockquote><p>With this approach, you will not need to specify the <i>CVRT</i> type parameter when calling <a href="../connections/README-txt.html#The_Connect_Function" class=LGroup id=link11 onMouseOver="ShowTip(event, 'tt3', 'link11')" onMouseOut="HideTip('tt3')">The Connect Function</a>.&nbsp; Your converter is automatically chosen by the compiler as an override (specialization) of the default converter.&nbsp; See <a href="sc_converter_class-cpp.html#UVMC_Converter_Example-SC_Converter_Class" class=LSection id=link12 onMouseOver="ShowTip(event, 'tt7', 'link12')" onMouseOut="HideTip('tt7')">UVMC Converter Example - SC Converter Class</a> for a complete example of using this approach.</p><p>See <a href="#Converter_Specialization,Macro-Generated" class=LGeneric id=link13 onMouseOver="ShowTip(event, 'tt8', 'link13')" onMouseOut="HideTip('tt8')">Converter Specialization, Macro-Generated</a>, next, for an approach that auto-generates the above converter specialization.</p></div></div></div>




 <!--CONTENT index=10 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Converter_Specialization,Macro-Generated" href="../../../uvmc/examples/converters/README.txt">Converter Specialization, Macro-Generated</a></h3><div class=CBody><p>Invoke a convenience macro that defines the converter specialization for you.</p><img src="../../../images/UVMC_Converters_SC_UserDefined.png" width="258" height="131"><p>The easist way to define a converter in SC is to invoke one of the <a href="../../src/connect/sc/uvmc_macros-h.html#UVMC_UTILS" class=LGeneric id=link14 onMouseOver="ShowTip(event, 'tt9', 'link14')" onMouseOut="HideTip('tt9')">UVMC_UTILS</a> macros.&nbsp; Using this option, our conversion class definition reduces to:</p><blockquote><pre>#include &quot;uvmc.h&quot;
using namespace uvmc;

UVMC_UTILS_3 (packet,cmd,addr,data)</pre></blockquote><p>That&rsquo;s it.&nbsp; The <i>UVMC_UTILS_3</i> macro expands into the converter specialization defined in <a href="#Converter_Specialization" class=LGeneric id=link15 onMouseOver="ShowTip(event, 'tt10', 'link15')" onMouseOut="HideTip('tt10')">Converter Specialization</a>, exactly.&nbsp; These macros are the &ldquo;good&rdquo; macros; they expand into efficient, readable code exactly as you would write it.&nbsp; See <a href="sc_converter_macros-cpp.html#UVMC_Converter_Example-SC_Converter_Class,Macro-Generated" class=LSection id=link16 onMouseOver="ShowTip(event, 'tt11', 'link16')" onMouseOut="HideTip('tt11')">UVMC Converter Example - SC Converter Class, Macro-Generated</a> for a complete example of using this approach.</p><p>Keep the following in mind when using the UTILS macros</p><ul><li>The number suffix in the macro name indicates the number of members of the class being converted.&nbsp; UVMC supports up to 20 field members, i.e. up to UVMC_UTILS_20.</li><li>The macros only support types for which the <i>uvmc_packer</i> defines the &lt;&lt; and &gt;&gt; operators.&nbsp; These include all C++ built-in types, strings, vectors, maps, and the SC types <i>sc_bit</i>, <i>sc_logic</i>, <i>sc_bv&lt;N&gt;</i>, <i>sc_lv&lt;N&gt;</i>, <i>sc_int&lt;N&gt;</i>, <i>sc_uint&lt;N&gt;</i>, <i>sc_unsigned&lt;N&gt;</i>, and <i>sc_time</i>.&nbsp; See <a href="../field_types/README-txt.html#UVMC_Type_Support" class=LSection id=link17 onMouseOver="ShowTip(event, 'tt12', 'link17')" onMouseOut="HideTip('tt12')">UVMC Type Support</a> for details.</li><li>The UTILS macros also define the <i>operator&lt;&lt;</i> to the output stream for your transaction.&nbsp; This allows you to stream your transaction contents to <i>cout</i> and other output streams.</li></ul><blockquote><pre>packet p;
...
cout &lt;&lt; &quot;Packet p contents are: &quot; &lt;&lt; p &lt;&lt; endl;</pre></blockquote><ul><li>The UTILS definition of <i>operator&lt;&lt;</i> to the output stream may interfere with other functions that define <i>operator&lt;&lt;(&amp;ostream)</i>.&nbsp; In this case, use a <a href="../../src/connect/sc/uvmc_macros-h.html#UVMC_CONVERT" class=LGeneric id=link18 onMouseOver="ShowTip(event, 'tt13', 'link18')" onMouseOut="HideTip('tt13')">UVMC_CONVERT</a> macro instead of the <a href="../../src/connect/sc/uvmc_macros-h.html#UVMC_UTILS" class=LGeneric id=link19 onMouseOver="ShowTip(event, 'tt9', 'link19')" onMouseOut="HideTip('tt9')">UVMC_UTILS</a> macro.&nbsp; The convert macros only define the converter specialization.&nbsp; They also support up to 20 field members.</li><li>All fields named in the UTILS macro invocation must be public members of the transaction.&nbsp; If they are not, and these members have accessor functions, you can still define an external converter via <a href="#Converter_Specialization" class=LGeneric id=link20 onMouseOver="ShowTip(event, 'tt10', 'link20')" onMouseOut="HideTip('tt10')">Converter Specialization</a> without the macros.</li></ul></div></div></div>




 <!--CONTENT index=11 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="In-Transaction-SC" href="../../../uvmc/examples/converters/README.txt">In-Transaction - SC</a></h3><div class=CBody><p>Define <i>do_pack</i> and <i>do_unpack</i> methods in the SC transaction itself.</p><p>Although this option works with SC&rsquo;s default converter, it is not recommended because it hard-codes the transaction to a particular packing and unpacking algorithm.&nbsp; Keeping the conversion functionality separate allows you to apply different conversion algorithms without having to modify or derive new transaction subtypes.</p><img src="../../../images/UVMC_Converters_SC_InTrans.png" width="389" height="131"><p>The following <i>packet</i> transaction definition provides both the content and conversion routines for the transaction.&nbsp; Because it is compatible with the default SC-side converter, you will not be required to specify converter class when connection with <a href="../connections/README-txt.html#The_Connect_Function" class=LGroup id=link21 onMouseOver="ShowTip(event, 'tt3', 'link21')" onMouseOut="HideTip('tt3')">The Connect Function</a>.&nbsp; See <a href="sc_converter_trans-cpp.html#UVMC_Converter_Example-SC_In-Transaction" class=LSection id=link22 onMouseOver="ShowTip(event, 'tt14', 'link22')" onMouseOut="HideTip('tt14')">UVMC Converter Example - SC In-Transaction</a> for a complete example of using this approach.</p><blockquote><pre>class packet;

  public:
  enum cmd_t { WRITE=0, READ, NOOP };

  cmd_t cmd;
  int addr;
  vector&lt;char&gt; data;

  virtual void do_pack(uvmc_packer &amp;packer) const {
    packer &lt;&lt; t.cmd &lt;&lt; t.addr &lt;&lt; t.data;
  }
  virtual void do_unpack(uvmc_packer &amp;packer) {
    packer &gt;&gt; t.cmd &gt;&gt; t.addr &gt;&gt; t.data;
  }
};</pre></blockquote></div></div></div>




 <!--CONTENT index=12 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Custom_Adaptor" href="../../../uvmc/examples/converters/README.txt">Custom Adaptor</a></h3><div class=CBody><p>Define a custom converter for a transaction whose members differ in number, type, size, and declaration order from the corresponding transaction definition in the other language.</p><img src="../../../images/UVMC_Converters_SC_UserDefinedAdapter.png" width="317" height="128"><p>With UVMC support for a separate converter class, you are not limited to member-by-member, bit-compatible packing and unpacking.&nbsp; The only requirement is that the two sides&rsquo; conversion routines agree on what and how data are represented in the bits being sent across the language boundary.</p><p>Thus, an array of four <i>bytes</i> in SV can be converted to a single <i>unsigned int</i> in SC.&nbsp;  A single <i>longint</i> in SV can be mapped to many possible combinations of the SC integrals: <i>int[2]</i>, <i>char[8]</i>, <i>vector&lt;char&gt;</i>, <i>sc_bit&lt;64&gt;</i>, <i>sc_int&lt;64&gt;</i>, etc.&nbsp; See <a href="sc_converter_adapter-cpp.html#UVMC_Converter_Example-SC_Adapter_Class" class=LSection id=link23 onMouseOver="ShowTip(event, 'tt15', 'link23')" onMouseOut="HideTip('tt15')">UVMC Converter Example - SC Adapter Class</a> for a complete example of using a &ldquo;full-custom&rdquo; approach to transaction conversion.</p></div></div></div>




 <!--CONTENT index=13 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Notes" href="../../../uvmc/examples/converters/README.txt">Notes</a></h3></div></div>




 <!--CONTENT index=14 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Type_Support" href="../../../uvmc/examples/converters/README.txt">Type Support</a></h3><div class=CBody><p>UVM Connect supports most of the built in types, arrays, and even sub-objects as properties of your transaction class.</p><p>The <i>uvmc_packer</i> supports packing and unpacking the following types</p><ul><li>bool</li><li>char, unsigned char</li><li>short, unsigned short</li><li>int, unsigned int</li><li>long, unsigned long</li><li>long long, unsigned long long</li><li>float</li><li>double</li><li>sc_bit</li><li>sc_logic</li><li>sc_bv&lt;N&gt;</li><li>sc_int&lt;N&gt;</li><li>sc_uint&lt;N&gt;</li><li>sc_bigint&lt;N&gt;</li><li>sc_biguint&lt;N&gt;</li><li>enums</li><li>T[N], where T is one of the above types</li><li>vector&lt;T&gt;, where T is one of the above types</li><li>list&lt;T&gt;, where T is one of the above types</li><li>map&lt;KEY,T&gt;, where KEY and T are among the above types</li></ul><p>See <a href="../field_types/README-txt.html#UVMC_Type_Support" class=LSection id=link24 onMouseOver="ShowTip(event, 'tt12', 'link24')" onMouseOut="HideTip('tt12')">UVMC Type Support</a> for more detail and examples.</p></div></div></div>




 <!--CONTENT index=15 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="On(not)using`uvm_field_macros" href="../../../uvmc/examples/converters/README.txt">On (not) using `uvm_field macros</a></h3><div class=CBody><p>The <i>`uvm_field</i> macros hurt run-time performance, can make debug more difficult, and can not accomodate custom behaviors, for example, conditional packing based on the value of another field.</p><p>In UVM 1.1a and prior, <i>uvm_tlm_generic_payload</i> uses the <i>`uvm_field</i> macros.&nbsp; Its definition expands into almost <i>600</i> lines of code, and it&rsquo;s wrong.&nbsp; The data and data_enable arrays should be packed according to the length and <i>byte_enable_length</i> fields, but the field macros do not accommodate this.&nbsp; They pack the entire data and byte_enable buffers, even if one one byte is valid.&nbsp; Replacing the `uvm_field macros with <i>do_</i> method implementations is planned for UVM 1.1b.&nbsp; See <a href="http://verificationacademy.com/uvm-ovm/MacroCostBenefit" class=LURL target=_top>http://verificationacademy.com<span class=HB>- </span>/uvm-ovm<span class=HB>- </span>/MacroCostBenefit</a> for more on macro usage in UVM.</p></div></div></div>




 <!--CONTENT index=16 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Packing_Algorithm" href="../../../uvmc/examples/converters/README.txt">Packing Algorithm</a></h3><div class=CBody><p>To pass an object across the language boundary, UVM Connect first calls <i>converter.do_pack</i>, which serializes the transaction contents to a simple bit-vector-like form.&nbsp; Upon return, your transaction&rsquo;s canonical representation will be stored inside the converter.&nbsp; UVM Connect retrieves and passes this canonical data across the language boundary using standard DPI-C.</p><p>On the target side, UVM Connect will unpack the canonical data into a new transaction object in the other language.&nbsp; To do this, UVM Connect first loads the data into the target-side converter.&nbsp; It then creates a new corresponding transaction object and passes it to converter.do_unpack, which does the reverse operation as pack.&nbsp; The converter unpacks the canonical data into the new transaction object, effectively reconstituting the original transaction object in the other language.&nbsp; This resulting transaction is then sent to the connected TLM target.</p><p>On the SV side, the default converter&rsquo;s implementations of <i>do_pack</i> and <i>do_unpack</i> delegate the work to the pack and unpack methods of your <i>uvm_object</i>-based transaction.&nbsp; If your transaction is not based on <i>uvm_object</i> (or <i>uvm_sequence_item</i>), or if your transaction object does not implement <i>do_pack</i> and <i>do_unpack</i>, you must define a converter for that transaction.</p><p>Like the SV side, the default converter on the SC side delegates to <i>do_pack</i> and <i>do_unpack</i> methods of the transaction object, <i>T</i>.&nbsp; SC-side transactions typically do not implement a UVM-compatible pack/unpack interface.&nbsp; In most cases, you will need to define a converter for each transaction type in SC.&nbsp; Fortunately, the UVM Connect library makes this very easy.</p></div></div></div>




 <!--CONTENT index=17 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Conversion_on_the_return_path" href="../../../uvmc/examples/converters/README.txt">Conversion on the return path</a></h3><div class=CBody><p>TLM2 communication is pass-by-reference, which we emulate in UVM Connect by copying back changes to the original transaction object upon return from every interface method call.</p><p>TLM1 communication is a pass-by-value message passing mechanism, so no conversion back to the original request object is done on the return path.</p></div></div></div>




 <!--CONTENT index=18 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Deletion_on_the_return_path" href="../../../uvmc/examples/converters/README.txt">Deletion on the return path</a></h3><div class=CBody><p>TLM2 rules mandate the same transaction object be used until the transaction execution is fully completed.&nbsp; This improves run-time efficiency.</p><p>For TLM2 blocking transport, the transaction is complete upon return, so it can be reused immediately in a subsequent call.&nbsp; The target should not retain a reference to any transaction object for this reason.&nbsp; It must copy the transaction before returning.</p><p>TLM2 non-blocking communication typically involves multiple calls back and forth between initiator and target.&nbsp; During this time, the same transaction object and its proxy on the other side are used throughout the call sequence.&nbsp; The target-side proxy object is not deleted (SC) or left for garbage collection (SV) until the returned status is TLM_COMPLETED.</p><p>TLM1 communication is a pass-by-value message passing mechanism, so the proxy transaction object on the target side is deleted or left for garbage collection upon return from the target.</p></div></div></div>




 <!--CONTENT index=19 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Default_Converters" href="../../../uvmc/examples/converters/README.txt">Default Converters</a></h3><div class=CBody><p>UVM Connect defines default converters in both SV and SC</p><p>All converters define <i>do_pack</i> and <i>do_unpack</i> static methods.&nbsp; UVMC calls upon these methods to convert an object into a form that can be transferred across the language boundary.&nbsp; UVMC defines default implementations of the converter, one each for SV and SC.</p></div></div></div>




 <!--CONTENT index=20 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Default_SV_Converter" href="../../../uvmc/examples/converters/README.txt">Default SV Converter</a></h3><div class=CBody><p>The default converter on the SV side is designed to work with <i>uvm_object</i>-based UVM transactions.&nbsp; It delegates the actual work to the <i>pack</i> and <i>unpack</i> methods in the transaction, which in turn call the virtual user-defined methods, <i>do_pack</i> and <i>do_unpack</i>.</p><blockquote><pre>class uvmc_default_converter #(type T=int)
                      extends uvmc_converter #(T);

 static function void do_pack(T t, uvm_packer packer);
    t.pack(packer); // calls t.do_pack
 endfunction

 static function void do_unpack(T t, uvm_packer packer);
    t.unpack(packer); // calls t.do_unpack
  endfunction

endclass</pre></blockquote><p>Our <i>packet</i> definition for the <a href="#In-Transaction" class=LGeneric id=link25 onMouseOver="ShowTip(event, 'tt4', 'link25')" onMouseOut="HideTip('tt4')">In-Transaction</a> approach is compatible with the default SV converter.&nbsp; This converter, as well as any custom converters you may define, are required to extend from <i>uvmc_converter #(your_trans_type)</i>.</p></div></div></div>




 <!--CONTENT index=21 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Default_SC_Converter" href="../../../uvmc/examples/converters/README.txt">Default SC Converter</a></h3><div class=CBody><p>The default converter on the SC side is meant to mirror the default in SV--it delegates to <i>do_pack</i> and <i>do_unpack</i> methods of your transaction type.</p><blockquote><pre>template &lt;typename T&gt;
class uvmc_converter {
  public:

  static void do_pack(const T &amp;t, uvmc_packer &amp;packer) {
    t.do_pack(packer);
  }

  static void do_unpack(T &amp;t, uvmc_packer &amp;packer) {
    t.do_unpack(packer);
  }
};</pre></blockquote><p>Most SC transaction definitions won&rsquo;t use this default converter.&nbsp; Instead, a <a href="#Converter_Specialization" class=LGeneric id=link26 onMouseOver="ShowTip(event, 'tt10', 'link26')" onMouseOut="HideTip('tt10')">Converter Specialization</a> is defined to handle your specific transaction type.&nbsp; The C++ compiler will then automatically choose your specialized definition over the default converter.</p></div></div></div>




 <!--CONTENT index=22 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Converter_Parameters_and_Methods" href="../../../uvmc/examples/converters/README.txt">Converter Parameters and Methods</a></h3><div class=CBody><p>The following describes the type parameters and methods of the converter class.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>T</td><td class=CDLDescription>The transaction type to be converted.&nbsp; The default converters requires T to provide the packing and unpacking functionality in <i>do_pack</i> and <i>do_unpack</i> methods.</td></tr></table><h4 class=CHeading>Methods</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>do_pack</td><td class=CDLDescription>Packs the given object of type T.&nbsp; The default implementation in SV requires T be derived from uvm_object, whose <i>do_pack</i> implementation or <i>`uvm_field</i> macros provide the packing functionality.&nbsp; The default implementation in SC requires T implement a <i>do_pack</i> method with the following prototype:</td></tr></table><blockquote><pre>void pack void do_pack (uvmc_packer &amp;packer) const;</pre></blockquote><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>do_unpack</td><td class=CDLDescription>Unpacks into given object of type T.&nbsp; The default implementation in SV requires T be derived from uvm_object, whose do_unpack implementation or `uvm_field macros provide the unpacking functionality.&nbsp; The default implementation in SC requires T implement an <i>do_unpack</i> method with the following prototype:</td></tr></table><blockquote><pre>void do_unpack (uvmc_packer &amp;packer);</pre></blockquote></div></div></div>




 <!--CONTENT index=23 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Converter_Examples" href="../../../uvmc/examples/converters/README.txt">Converter Examples</a></h3><div class=CBody><p>The directory <i>UVMC_HOME/examples/converters</i>  contains several examples of transaction conversion in both SystemC (SC) and SystemVerilog (SV)</p><p>How a transaction is converted on one side does not effect your options on the other side.&nbsp; With four ways to convert a transaction in SC and three ways to do this in SV, there are a total of 12 combinations.&nbsp;  We provide an example for each of these 12 combinations.</p><p>See &lt;Getting Started&gt; for setup requirements for running the examples.&nbsp; Specifically, you will need to have precompiled the UVM and UVMC libraries and set environment variables pointing to them.</p><p>Use <i>make help</i> to view the menu of available examples</p><blockquote><pre>&gt; make help</pre></blockquote><p>You&rsquo;ll get a menu similar to the following</p><blockquote><pre> -----------------------------------------------------------------
|                  UVMC EXAMPLES - CONVERTERS                     |
 -----------------------------------------------------------------
|                                                                 |
| Usage:                                                          |
|                                                                 |
|   make [UVM_HOME=path] [UVMC_HOME=path] &lt;example&gt;               |
|                                                                 |
| where &lt;example&gt; is one or more of:                              |
|                                                                 |
|   ex01 : SV conversion done in UVM transaction                  |
|          SC conversion done in macro-generated converter class  |
|                                                                 |
|   ex02 : SV conversion done in UVM transaction                  |
|          SC conversion done in separate converter class         |
|                                                                 |
|   ex03 : SV conversion done in UVM transaction                  |
|          SC conversion done in transaction                      |
|                                                                 |
|   ex04 : SV conversion done in UVM transaction via field macros |
|          SC conversion done in macro-generated converter class  |
|                                                                 |
|   ex05 : SV conversion done in UVM transaction via field macros |
|          SC conversion done in separate converter class         |
|                                                                 |
|   ex06 : SV conversion done in UVM transaction via field macros |
|          SC conversion done in transaction                      |
|                                                                 |
|   ex07 : SV conversion done in separate converter class;        |
|                  transaction is not based on uvm_object         |
|          SC conversion done in macro-generated converter class  |
|                                                                 |
|   ex08 : SV conversion done in separate converter class;        |
|                  transaction is not based on uvm_object         |
|          SC conversion done in separate converter class         |
|                                                                 |
|   ex09 : SV conversion done in separate converter class;        |
|                  transaction is not based on uvm_object         |
|          SC conversion done in transaction                      |
|                                                                 |
|   ex10 : SV conversion done in UVM transaction                  |
|          SC-side implements converter that converts and adapts  |
|                  to an otherwise incompatible transaction type  |
|                                                                 |
|   ex11 : SV conversion done in UVM transaction via field macros |
|          SC-side implements converter that converts and adapts  |
|                  to an otherwise incompatible transaction type  |
|                                                                 |
|   ex12 : SV-side implements converter in separate class;        |
|                  transaction is not based on uvm_object         |
|          SC-side implements converter that converts and adapts  |
|                  to an otherwise incompatible transaction type  |
|                                                                 |
| UVM_HOME and UVMC_HOME specify the location of the source       |
| headers and macro definitions needed by the examples. You must  |
| specify their locations via UVM_HOME and UVMC_HOME environment  |
| variables or make command line options. Command line options    |
| override any envrionment variable settings.                     |
|                                                                 |
| The UVM and UVMC libraries must be compiled prior to running    |
| any example. If the libraries are not at their default location |
| (UVMC_HOME/lib) then you must specify their location via the    |
| UVM_LIB and/or UVMC_LIB environment variables or make command   |
| line options. Make command line options take precedence.        |
|                                                                 |
| Other options:                                                  |
|                                                                 |
|   all   : Run all examples                                      |
|   clean : Remove simulation files and directories               |
|   help  : Print this help information                           |
|                                                                 |
|                                                                 |
 -----------------------------------------------------------------</pre></blockquote><p>To run just one example</p><blockquote><pre>&gt; make ex01</pre></blockquote><p>This compiles and runs Example 1, which demonstrates the recommended converter implementation option in both SC and SV.&nbsp; The UVM source location is defined by the <i>UVM_HOME</i> environment variable, and the UVM and UVMC compiled libraries are searched at their default location, <i>../../lib/uvmc_lib</i>.</p><p>To run all examples</p><blockquote><pre>&gt; make all</pre></blockquote><p>The <i>clean</i> target deletes all the simulation files produced from previous runs.</p><blockquote><pre>&gt; make clean</pre></blockquote><p>You can combine targets in one command line</p><blockquote><pre>&gt; make clean ex03</pre></blockquote><p>The following runs the &lsquo;ex10&rsquo; example, providing the path to the UVM source and compiled library on the <i>make</i> command line.</p><blockquote><pre>&gt; make UVM_HOME=&lt;path&gt; UVM_LIB=&lt;path&gt; ex10</pre></blockquote><blockquote><pre>//------------------------------------------------------------//
//   Copyright 2009-2015 Mentor Graphics Corporation          //
//   All Rights Reserved Worldwide                            //
//                                                            //
//   Licensed under the Apache License, Version 2.0 (the      //
//   &quot;License&quot;); you may not use this file except in          //
//   compliance with the License.  You may obtain a copy of   //
//   the License at                                           //
//                                                            //
//       http://www.apache.org/licenses/LICENSE-2.0           //
//                                                            //
//   Unless required by applicable law or agreed to in        //
//   writing, software distributed under the License is       //
//   distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR   //
//   CONDITIONS OF ANY KIND, either express or implied.  See  //
//   the License for the specific language governing          //
//   permissions and limitations under the License.           //
//------------------------------------------------------------//</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CGroup>UVM Connect defines default converters in both SV and SC</div></div><div class=CToolTip id="tt2"><div class=CSection>This example shows how to implement the conversion routines in UVM-style transaction in the virtual <i>do_pack</i> and <i>do_unpack</i> functions inherited from the <i>uvm_object</i> base class.</div></div><div class=CToolTip id="tt3"><div class=CGroup>The <i>connect</i> and <i>connect_hier</i> functions are used to register any type of TLM port, export, interface, imp, or socket for connection across the language boundary.</div></div><div class=CToolTip id="tt4"><div class=CGeneric>This approach defines the conversion algorithm in transaction class itself.</div></div><div class=CToolTip id="tt5"><div class=CSection>This example demonstrates how to define a custom converter for a transaction class that does not extend from <i>ovm_object</i>.</div></div><div class=CToolTip id="tt6"><div class=CSection>This example shows a UVM-style transaction that uses the `uvm_field macros to implement the required conversion functionality.</div></div><div class=CToolTip id="tt7"><div class=CSection>This example demonstrates how to define an external converter class for a given transaction type. </div></div><div class=CToolTip id="tt8"><div class=CGeneric>Invoke a convenience macro that defines the converter specialization for you.</div></div><div class=CToolTip id="tt9"><div class=CGeneric>Generate both a converter specialization and output stream <i>operator&lt;&lt;</i> for the given transaction <i>TYPE</i>.</div></div><div class=CToolTip id="tt10"><div class=CGeneric>Define a separate class for converting your transaction type.</div></div><div class=CToolTip id="tt11"><div class=CSection>This example demonstrates how to define an external converter for a transaction class using a UVMC_UTILS macro. </div></div><div class=CToolTip id="tt12"><div class=CSection>The members of your transaction definitions may be any collection of the following types, which have direct support in UVMC. </div></div><div class=CToolTip id="tt13"><div class=CGeneric>Generate a converter specialization of <i>uvmc_convert&lt;T&gt;</i> for the given transaction <i>TYPE</i>.</div></div><div class=CToolTip id="tt14"><div class=CSection>This example&rsquo;s packet class defines <i>do_pack</i> and <i>do_unpack</i> methods that are compatible with the default converter in SC. </div></div><div class=CToolTip id="tt15"><div class=CSection>This example demonstrates how to define a custom converter for a transaction class whose members differ in number, type, and size from the corresponding transaction definition in SV. </div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>