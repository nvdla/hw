<html><head><title>UVMC Converter Example - SC Adapter Class</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="UVMC_Converter_Example-SC_Adapter_Class" href="../../../uvmc/examples/converters/sc_converter_adapter.cpp">UVMC Converter Example - SC Adapter Class</a></h1><div class=CBody><p>This example demonstrates how to define a custom converter for a transaction class whose members differ in number, type, and size from the corresponding transaction definition in SV.&nbsp; This situation can arise in cases where the transaction types are pre-existing in both SC and SV yet have compatible content.</p><img src="../../../images/UVMC_Converters_SC_UserDefinedAdapter.png" width="317" height="128"><p>Because most SC transactions do not implement the pack and unpack member functions required by the default converter, a template specialization definition is required.&nbsp; A template specialization can be defined by hand or via a <a href="../../src/connect/sc/uvmc_macros-h.html#UVMC_UTILS" class=LGeneric id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">UVMC_UTILS</a> macro, which defines the same converter specialization plus the operator&lt;&lt; for the default output stream (cout).&nbsp;  This allows you to print your packet contents using cout &lt;&lt; my_packet;</p><p>Template specializations are chosen automatically by the C+ compiler, so you will not need to specify the converter type explicitly when connecting via <a href="../connections/README-txt.html#The_Connect_Function" class=LGroup id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">The Connect Function</a>.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#UVMC_Converter_Example-SC_Adapter_Class" >UVMC Converter Example - SC Adapter Class</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This example demonstrates how to define a custom converter for a transaction class whose members differ in number, type, and size from the corresponding transaction definition in SV. </td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#User_Library" >User Library</a></td><td class=SDescription>This section defines a transaction class and generic consumer model. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Conversion_code" >Conversion code</a></td><td class=SDescription>This section defines a converter specialization for our &lsquo;packet&rsquo; transaction type. </td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Testbench_code" >Testbench code</a></td><td class=SDescription>This section defines our testbench environment. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="User_Library" href="../../../uvmc/examples/converters/sc_converter_adapter.cpp">User Library</a></h3><div class=CBody><p>This section defines a transaction class and generic consumer model.&nbsp; We will define a converter for this packet, then connect an instance of the consumer with an SV-side producer using a blocking transport interface  conveying that transaction.</p><blockquote><pre>namespace user_lib {

  class packet
  {
    public:
    short addr_hi;
    short addr_lo;
    unsigned int payload[4];
    char  len;
    bool  write; // 1=write, 0=read
  };
}</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Conversion_code" href="../../../uvmc/examples/converters/sc_converter_adapter.cpp">Conversion code</a></h3><div class=CBody><p>This section defines a converter specialization for our &lsquo;packet&rsquo; transaction type.&nbsp; We can not use the default converter because it delegates to <i>pack</i> and <i>unpack</i> methods of the transaction, which our packet class doesn&rsquo;t have.</p><p>So, we define a converter template specialization for our packet type.&nbsp; Your transaction converters would implement the same template.</p><p>The definition of a SC-side converter specialization is so regular that a set of convenient macros have been developed to produce a converter class definition for you.&nbsp; You would invoke one of the macros from the set, depending on the number of fields in your transaction class and whether it inherits from a base class.&nbsp; See <a href="sc_converter_macros-cpp.html#UVMC_Converter_Example-SC_Converter_Class,Macro-Generated" class=LSection id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">UVMC Converter Example - SC Converter Class, Macro-Generated</a> for for an example of using the <a href="../../src/connect/sc/uvmc_macros-h.html#UVMC_UTILS" class=LGeneric id=link4 onMouseOver="ShowTip(event, 'tt1', 'link4')" onMouseOut="HideTip('tt1')">UVMC_UTILS</a> macros.</p><p>The corresponding transaction in SV declares the following fields, split across two classes (one inheriting from the other), in the given order.</p><blockquote><pre>class packet_base extends uvm_sequence_item:
  typedef enum {WRITE, READ, NOOP} cmd_t;
  cmd_t cmd;
  int   addr;
  byte  data[$];
endclass

class packet:
  int extra_int;
endclass</pre></blockquote><p>If we could define our SC-side transaction to suit this definition, we&rsquo;d mirror the types, declaration order, and even the inheritance hierarchy.&nbsp; In this example, however, we are faced with having to adapt to a pre-existing transaction type.</p><p>When writing the converters on the SV and SC side, we can choose three different ways:</p><p>1: Let the SC converter pack/unpack normally; implement a custom SV converter to convert according to how the SC side expects to receive the bits.</p><p>2: Let the SV converter pack/unpack normally; implement a SC converter specialization of the default SC converter to convert according to how the SV side expects to receive the bits.</p><p>3: Let the SV converter pack/unpack normally; implement a subtype to the SC converter specialization to convert according to how the SV side expects to receive the bits.&nbsp; Specify the custom converter type when calling uvmc_connect.</p><p>A converter specialization, e.g.&nbsp;  <i>template &lt;&gt; class uvmc_converter&lt;packet&gt;</i>, should be reserved for converting the SC transaction as it is defined, streaming each field in order and without adaptation.&nbsp;  It should not be used to adapt to a custom mapping on the SV side, as in this example.&nbsp; For this reason, option 3 is the best.</p><p>The <i>packet</i> transaction in SV will be packed normally: <i>cmd</i>, <i>addr</i>, <i>data</i>, and <i>extra_int</i>.&nbsp; The SV packetized bits, assuming 3 bytes in the data array, looks like this:</p><blockquote><pre> ____________________________________
| cmd    |  addr  |d0|d1|d2|extra_int|
|________|________|__|__|__|_________|
 0        32       64 72 80 88</pre></blockquote><p>In SC, we shall adapt as follows</p><ul><li>map the 32-bit <i>cmd</i> from SV to a single <i>bool</i> in SV</li><li>map the 32-bit <i>addr</i> from SV to two <i>addr_lo</i> and <i>addr_hi</i> 16-bit values in SC</li><li>map the <i>data</i> byte array data from SV to an integer array in SV</li></ul><p>When dealing with built-in types, you should account for the endianess of your machine&rsquo;s architecture.&nbsp; This example assumes a little-endian architecture.</p><blockquote><pre>#include &lt;vector&gt;
#include &lt;iomanip&gt;
using std::vector;

#include &quot;uvmc.h&quot;
using namespace uvmc;
using namespace user_lib;

struct packet_converter : public uvmc_converter&lt;packet&gt;
{
  static void do_pack(const packet &amp;t, uvmc_packer &amp;packer) {
    int cmd_tmp;
    if (t.write)
      cmd_tmp = 0;
    else
      cmd_tmp = 1;
    packer &lt;&lt; cmd_tmp
           &lt;&lt; t.addr_lo &lt;&lt; t.addr_hi
           &lt;&lt; (int)(t.len) &lt;&lt; t.payload;
  }

  static void do_unpack(packet &amp;t, uvmc_packer &amp;packer) {
    int cmd_tmp;
    vector&lt;unsigned char&gt; data_tmp;
    packer &gt;&gt; cmd_tmp &gt;&gt; t.addr_lo &gt;&gt; t.addr_hi &gt;&gt; data_tmp;
    t.len = data_tmp.size();
    if (cmd_tmp == 0)
      t.write = 1;
    else if (cmd_tmp == 1)
      t.write = 0;
    else
      cout &lt;&lt; &quot;packet cmd from SV side has unsupported value &quot;
           &lt;&lt; cmd_tmp &lt;&lt; endl;
    for (int i=0;i&lt;4;i++)
      t.payload[i]=0;
    for (int i=0;i&lt;4;i++) {
      for (int j=0;j&lt;4;j++) {
        if ((i*4+j)&lt;t.len) {
          int b;
          b = data_tmp[i*4+j] &lt;&lt; (8*j);
          t.payload[i] = t.payload[i] | b;
        }
        else {
          break;
        }
      }
    }
  }

};

UVMC_PRINT_4(packet,addr_hi,addr_lo,len,write)</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Testbench_code" href="../../../uvmc/examples/converters/sc_converter_adapter.cpp">Testbench code</a></h3><div class=CBody><p>This section defines our testbench environment.&nbsp; In the top-level  module, we instantiate the generic consumer model.&nbsp; We also register  the consumer&rsquo;s &lsquo;in&rsquo; export to have a UVMC connection with a lookup  string &lsquo;stimulus&rsquo;.&nbsp; The SV-side will register its producer&rsquo;s &lsquo;out&rsquo;  port with the same &lsquo;stimulus&rsquo; lookup string.&nbsp; UVMC will match these two strings to complete the cross- language connection, i.e. the SV producer&rsquo;s <i>out</i> port will be bound to the SC consumer&rsquo;s <i>in</i> export.</p><blockquote><pre>#include &quot;systemc.h&quot;
#include &quot;tlm.h&quot;
using namespace sc_core;
using namespace tlm;

// a generic target with a TLM2 b_transport export
#include &quot;consumer2.cpp&quot;

class sc_env : public sc_module
{
  public:
  consumer&lt;packet&gt; cons;

  sc_env(sc_module_name nm) : cons(&quot;cons&quot;) {
    uvmc_connect&lt;packet_converter&gt;(cons.in,&quot;stimulus&quot;);
  }
};

// Define sc_main, the vendor-independent means of starting a
// SystemC simulation.

int sc_main(int argc, char* argv[])
{
  sc_env env(&quot;env&quot;);
  sc_start();
  return 0;
}</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CGeneric>Generate both a converter specialization and output stream <i>operator&lt;&lt;</i> for the given transaction <i>TYPE</i>.</div></div><div class=CToolTip id="tt2"><div class=CGroup>The <i>connect</i> and <i>connect_hier</i> functions are used to register any type of TLM port, export, interface, imp, or socket for connection across the language boundary.</div></div><div class=CToolTip id="tt3"><div class=CSection>This example demonstrates how to define an external converter for a transaction class using a UVMC_UTILS macro. </div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>