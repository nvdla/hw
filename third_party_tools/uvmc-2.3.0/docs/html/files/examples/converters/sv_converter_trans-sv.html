<html><head><title>UVMC Converter Example - SV In-Transaction</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="UVMC_Converter_Example-SV_In-Transaction" href="../../../uvmc/examples/converters/sv_converter_trans.sv">UVMC Converter Example - SV In-Transaction</a></h1><div class=CBody><p>This example shows how to implement the conversion routines in UVM-style transaction in the virtual <i>do_pack</i> and <i>do_unpack</i> functions inherited from the <i>uvm_object</i> base class.</p><img src="../../../images/UVMC_Converters_SV_InTrans.png" width="393" height="128"><p>Most SV transactions extend <i>uvm_sequence_item</i>, which extends <i>uvm_object</i>, which defines virtual <i>do_pack</i> and <i>do_unpack</i> methods for override in user-defined transaction types.&nbsp; The UVMC&rsquo;s default converter for SV works for these types of transactions.&nbsp; Defining SV-side transasctions in this way minimizes the extra code needed to make a cross-language connection.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#UVMC_Converter_Example-SV_In-Transaction" >UVMC Converter Example - SV In-Transaction</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This example shows how to implement the conversion routines in UVM-style transaction in the virtual <i>do_pack</i> and <i>do_unpack</i> functions inherited from the <i>uvm_object</i> base class.</td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#User_Library" >User Library</a></td><td class=SDescription>This section defines a transaction class, <i>packet</i>, that indirectly extends <i>uvm_object</i>. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Conversion_code" >Conversion code</a></td><td class=SDescription>This section is empty because our conversion functionality is built into the transaction proper.</td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Testbench_code" >Testbench code</a></td><td class=SDescription>This section defines our testbench environment. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="User_Library" href="../../../uvmc/examples/converters/sv_converter_trans.sv">User Library</a></h3><div class=CBody><p>This section defines a transaction class, <i>packet</i>, that indirectly extends <i>uvm_object</i>.&nbsp; It also defines a generic producer model via an `include.&nbsp; All transactions and components in the  user library should be written to be independent of context, i.e. not assume a UVMC or any other outside connetion.</p><p>The <i>`uvm_pack_*</i> and <i>`uvm_unpack_*</i> macros expand into two or so lines of code that are more efficient than using the packer&rsquo;s API directly.&nbsp; These macros are part of the UVM standard and are documented under the <i>Macros</i> heading in the UVM Reference Manual.</p><blockquote><pre>package user_pkg;

  `include &quot;uvm_macros.svh&quot;
  import uvm_pkg::*;

  class packet_base extends uvm_sequence_item;

    `uvm_object_utils(packet_base)

    typedef enum { WRITE, READ, NOOP } cmd_t;

    rand cmd_t cmd;
    rand int   addr;
    rand byte  data[$];

    function new(string name=&quot;&quot;);
      super.new(name);
    endfunction

    constraint c_data_size { data.size() inside { [1:10] }; }

    virtual function void do_pack(uvm_packer packer);
      `uvm_pack_enum(cmd)
      `uvm_pack_int(addr)
      `uvm_pack_queue(data)
    endfunction

    virtual function void do_unpack(uvm_packer packer);
      `uvm_unpack_enum(cmd,cmd_t)
      `uvm_unpack_int(addr)
      `uvm_unpack_queue(data)
    endfunction

    virtual function string convert2string();
      return $sformatf(&quot;cmd:%s addr:%h data:%p&quot;,cmd,addr,data);
    endfunction

  endclass


  class packet extends packet_base;

    `uvm_object_utils(packet)

    rand int extra_int;

    function new(string name=&quot;&quot;);
      super.new(name);
    endfunction

    virtual function void do_pack(uvm_packer packer);
      super.do_pack(packer);
      `uvm_pack_int(extra_int)
    endfunction

    virtual function void do_unpack(uvm_packer packer);
      super.do_unpack(packer);
      `uvm_unpack_int(extra_int)
    endfunction

    virtual function string convert2string();
      return $sformatf(&quot;%s extra_int:%h&quot;,super.convert2string(),extra_int);
    endfunction

  endclass

  `include &quot;producer.sv&quot;

endpackage : user_pkg</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Conversion_code" href="../../../uvmc/examples/converters/sv_converter_trans.sv">Conversion code</a></h3><div class=CBody><p>This section is empty because our conversion functionality is built into the transaction proper.</p><blockquote><pre>/***  No external conversion code needed  ***/</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Testbench_code" href="../../../uvmc/examples/converters/sv_converter_trans.sv">Testbench code</a></h3><div class=CBody><p>This section defines our testbench environment.&nbsp; In the env&rsquo;s <i>build</i> function, we instantiate the generic producer model.&nbsp; In the <i>connect</i> method, we register the producer&rsquo;s <i>out</i> port for UVMC connection using the lookup string &lsquo;stimulus&rsquo;.&nbsp; The SC-side will register its consumer&rsquo;s <i>in</i> port with the same lookup string.&nbsp; UVMC will match these two strings and complete the cross- language connection, i.e. the SV producer&rsquo;s <i>out</i> port will be bound to the SC consumer&rsquo;s <i>in</i> export.</p><p>Because our <i>packet</i> class implements the requisite <i>do_pack</i> and <i>do_unpack</i> methods, we can leverage UVMC&rsquo;s default converter, which delegates to these methods.&nbsp; When making the uvmc_tlm::connect call, we do not need to specify a custom converter type--only the transaction type.</p><blockquote><pre>module sv_main;

  `include &quot;uvm_macros.svh&quot;
  import uvm_pkg::*;
  import uvmc_pkg::*;
  import user_pkg::*;

  // Define env with connection specifying custom converter

  class sv_env extends uvm_env;

    producer #(packet) prod;

    `uvm_component_utils(sv_env)

    function new(string name, uvm_component parent=null);
       super.new(name,parent);
    endfunction

    function void build_phase(uvm_phase phase);
       prod = new(&quot;prod&quot;, this);
    endfunction

    function void connect_phase(uvm_phase phase);
      uvmc_tlm #(packet)::connect(prod.out, &quot;stimulus&quot;);
    endfunction

  endclass


  sv_env env;

  initial begin
    env = new(&quot;env&quot;);
    run_test();
  end

endmodule</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>