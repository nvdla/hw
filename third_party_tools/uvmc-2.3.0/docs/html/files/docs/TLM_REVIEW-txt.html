<html><head><title>TLM Review</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script language=JavaScript src="../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="TLM_Review" href="../../uvmc/docs/TLM_REVIEW.txt">TLM Review</a></h1><div class=CBody><p>This section provides a basic introduction to TLM ports, exports, interfaces, and sockets as well as basic rules for connecting them.&nbsp; See the <a href="OVERVIEW-txt.html#References" class=LGroup id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">References</a> section for more in-depth materials, including the IEEE 1666-2011, the SystemC LRM that defines the TLM standard.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#TLM_Review" >TLM Review</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This section provides a basic introduction to TLM ports, exports, interfaces, and sockets as well as basic rules for connecting them. </td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Terms" >Terms</a></td><td class=SDescription>Definitions of terms used throughout this document.</td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Context_Independence" >Context Independence</a></td><td class=SDescription>The purpose of TLM is to allow components to be self-contained, independent of the myriad ways they might be connected in a testbench. </td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Ports" >Ports</a></td><td class=SDescription>Ports are used to call interface methods implemented elsewhere.</td></tr>
  <!-- index=4 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#InterfacesImps" >Interfaces &amp; Imps</a></td><td class=SDescription>An <i>interface</i> in SC and an <i>imp</i> in SV UVM are used to expose to the outside world an implementation of a standard TLM interface, which is a group of methods with predefined signatures and semantics. </td></tr>
  <!-- index=5 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Exports" >Exports</a></td><td class=SDescription>Exports promote an interface (or imp) implementation from a child to its parent.</td></tr>
  <!-- index=6 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Analysis" >Analysis</a></td><td class=SDescription>Analysis ports, exports, and imps are used to monitor transaction flow and help you debug your designs. </td></tr>
  <!-- index=7 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#TLM_Initiator_Socket" >TLM Initiator Socket</a></td><td class=SDescription>Sockets are a convenient way to make TLM2 connections; in fact, most TLM2 connections are made with sockets, not individual interface connections.</td></tr>
  <!-- index=8 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#TLM_Target_Socket" >TLM Target Socket</a></td><td class=SDescription>A component having a target socket receives transaction on its forward interface and, if non-blocking, sends responses to the initiator via the backward path.</td></tr>
  <!-- index=9 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#Socket_Connections" >Socket Connections</a></td><td class=SDescription>A socket is used to connect a forward and backward path between an initiator and target using a single <i>connect</i> or <i>bind</i> call. </td></tr>
  <!-- index=10 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Legal_TLM_Connections" >Legal TLM Connections</a></td><td class=SDescription>TLM port connections are like Verilog module port connections except you&rsquo;re connecting interfaces not wires. </td></tr>
  <!-- index=11 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#TLM_Generic_Payload" >TLM Generic Payload</a></td><td class=SDescription>TLM 2.0 defines a canonical transaction type, <i>tlm_generic_payload</i>, or <i>tlm_gp</i> for short. </td></tr>
  <!-- index=12 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#TLM1_combination_interfaces" >TLM1 combination interfaces</a></td><td class=SDescription>TLM ports <i>require</i> a connection to an implementation of its interface type, while TLM exports, interfaces, and imps <i>provide</i> the implementation. </td></tr>
  <!-- index=13 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#UVMC_TLM_Connections" >UVMC TLM Connections</a></td><td class=SDescription>Getting your SystemC TLM models and SystemVerilog UVM components talking to each other breaks down to two steps</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Terms" href="../../uvmc/docs/TLM_REVIEW.txt">Terms</a></h3><div class=CBody><p>Definitions of terms used throughout this document.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>SV</td><td class=CDLDescription>SystemVerilog, or UVM in SystemVerilog.&nbsp; The context will make clear which.&nbsp; In figures, UVM SV components are shown in blue.</td></tr><tr><td class=CDLEntry>SC</td><td class=CDLDescription>SystemC.&nbsp; In figures, SC components are shown in yellow.</td></tr><tr><td class=CDLEntry>model</td><td class=CDLDescription>Functionality encapsulated by a class.&nbsp; A model is typically a subtypes (derived from) of <i>sc_module</i> in SC and <i>uvm_component</i> in SV.&nbsp; Although dynamic in nature, models deriving from these classes are quasi-static; they are created during elaboration of the testbench and continue to exist throughout simulation.</td></tr><tr><td class=CDLEntry>component</td><td class=CDLDescription>Synonymous with <i>model</i>, above.</td></tr><tr><td class=CDLEntry>hierarchical component</td><td class=CDLDescription>A model contains one or more models.</td></tr><tr><td class=CDLEntry>TLM</td><td class=CDLDescription>Transaction-Level Model.&nbsp; TLM models exchange information as objects, not the discrete signals or wires you see in RTL.&nbsp; Transactions abstract away the low-level RTL details in exchange for speed and easier maintenance.&nbsp; To be reusable, TLM models should communicate via standard TLM1 or TLM2 interfaces.</td></tr><tr><td class=CDLEntry>interface</td><td class=CDLDescription>A class that defines one or more method prototypes but does not implement them.&nbsp; Classes inheriting from an interface must implement the methods defined in the interface.&nbsp; TLM1 and TLM2 define several interfaces for transaction-level communication.&nbsp; Models that implement an interface are referred to as <i>targets</i>.</td></tr><tr><td class=CDLEntry>imp</td><td class=CDLDescription>SV only.&nbsp; Like an interface, except instead of providing an interface implementation through inheritance, the <i>imp</i> is an object that provides an interface through delegation.&nbsp; It is a SV workaround to lack of multiple inheritance.</td></tr><tr><td class=CDLEntry>export</td><td class=CDLDescription>An object that conveys (exports) an interface implementation from the child to the parent level.&nbsp; Exports can also be connected to other exports for purposes of promoting the interface implementation as high in the model hierarchy as needed.</td></tr><tr><td class=CDLEntry>port</td><td class=CDLDescription>An object through which interface calls are made.&nbsp; A port is connected to the interface implementation via a combination of parent port-export-imp connections.&nbsp; Thus, calls to a port in an initiator component end up calling the method implementations in the target component, with neither the initiator nor target knowing about each other.</td></tr></table><p>Who initiates requests and who services them dictates the control flow relationship between models.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>initiator</td><td class=CDLDescription>A component that initiates transaction requests.&nbsp; Initiators typically contain at least one port or initiator_socket.</td></tr><tr><td class=CDLEntry>target</td><td class=CDLDescription>A component to which transaction requests are sent.&nbsp; Targets typically implement an interface (SC) or contain at an initiator_socket or imp.</td></tr></table><p>Who creates the transactions and who processes them dictate the data flow relationship between models.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>producer</td><td class=CDLDescription>A component that produces transactions.</td></tr><tr><td class=CDLEntry>consumer</td><td class=CDLDescription>A component that consumes or executes transactions.</td></tr></table><p>There are thus four combinations of control and data flow possible for any given TLM connection.</p><ul><li><i>Initiator-producers</i> create transactions and send them out TLM ports or sockets.</li><li><i>Target-consumers</i> receive transactions from initiator-producers via TLM exports, interfaces, imps, or sockets.&nbsp; <i>Initiator-consumers</i> request transactions from target-producers via TLM ports or sockets.</li><li><i>Initiator-consumers</i> request transactions from connected <i>target-producers</i>.&nbsp; Although it does not use a standard TLM interface, the UVM driver is an example of a <i>initiator-consumer</i>.</li><li><i>Target-producers</i> create transactions upon request from <i>initiator-consumers</i>.&nbsp; Although not a component using standard TLM, the UVM sequencer is an example of a <i>target-producer</i>, accepting requests for transactions from the driver.</li></ul></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Context_Independence" href="../../uvmc/docs/TLM_REVIEW.txt">Context Independence</a></h3><div class=CBody><p>The purpose of TLM is to allow components to be self-contained, independent of the myriad ways they might be connected in a testbench.&nbsp; Likewise, connections should be not depend on the components&rsquo; internal implementation details.&nbsp; The TLM standard defines the set of common interfaces and semantics required to make successful connections to independently developed components.</p><p>Provided the IP you intend to integrate has properly applied the principles of context independence and TLM connectivity, mixed-language interoperability with UVMC can be achieved with no modifications to the IP on either side of the language boundary.</p><p>The examples included in this kit reinforce these concepts.&nbsp; All examples are fully documented with diagrams, explanations, and code in hyperlinked HTML.&nbsp; Together they show you step-by-step how to integrate existing IP in a mixed SystemC / SystemVerilog environment.</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Ports" href="../../uvmc/docs/TLM_REVIEW.txt">Ports</a></h3><div class=CBody><p>Ports are used to call interface methods implemented elsewhere.</p><ul><li>Ports are the &ldquo;starting point&rdquo; for communication by initiators</li><li>The testbench developer (integrator) connects ports external to the owner of th eport.</li><li>Ports are depicted as square in diagrams</li></ul><img src="../../images/UVMC_TLM_Overview_Ports.png" width="310" height="136"><h4 class=CHeading>SC Example</h4><blockquote><pre>class producer : public sc_module
{
  sc_port&lt;tlm_blocking_put_if&lt;packet&gt; &gt; out;  &lt;--

  producer(sc_module_name nm) : out(&quot;out&quot;){
     SC_THREAD(run);
  }

  void run() {
     packet t;
     ...initialize/randomize packet...
     out-&gt;put(t); &lt;--
  }

};</pre></blockquote><h4 class=CHeading>SV Example</h4><blockquote><pre>class producer extends uvm_component
{
  tlm_blocking_put_port #(packet) out; &lt;--

  `uvm_component_utils(producer)

  function new (string name, uvm_component parent=null);
    super.new(name,parent);
    out = new(&quot;out&quot;,  this);
  endfunction

  virtual task run_phase (uvm_phase phase);
    packet t = packet::type_id::create(&quot;tr&quot;,this);
    t.randomize();
    `uvm_info(&quot;PRODUCER/PKT/SEND&quot;, t.sprint(),UVM_MEDIUM)
    out.put(t);   &lt;--
  endtask
};</pre></blockquote></div></div></div>




 <!--CONTENT index=4 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="InterfacesImps" href="../../uvmc/docs/TLM_REVIEW.txt">Interfaces &amp; Imps</a></h3><div class=CBody><p>An <i>interface</i> in SC and an <i>imp</i> in SV UVM are used to expose to the outside world an implementation of a standard TLM interface, which is a group of methods with predefined signatures and semantics.&nbsp; The interface is typically a small subset of a component&rsquo;s overall API.&nbsp; Thus, the TLM interface and imp minimize the coupling between components by exposing only the standard portion of its API.</p><ul><li>Imps/interfaces are &ldquo;end points&rdquo; in a network of port/export/interface connections</li><li>Inteface methods are called via ports bound to the interface/imp, NOT directly</li><li>Interfaces/imps are depicted as a circle in diagrams</li></ul><h4 class=CHeading>SC Example</h4><p>In SC, target components inherit the interface &amp; implement the interface&rsquo;s methods</p><img src="../../images/UVMC_TLM_Overview_Interfaces.png" width="378" height="139"><blockquote><pre>class consumer : public sc_module,
                 tlm_blocking_put_if&lt;packet&gt; &lt;-- interface inherited
{
   public:
   consumer(sc_module_name nm) { }

  virtual void put(const packet &amp;t) {    &lt;-- implementation
    cout &lt;&lt; &quot;Got packet: &quot; &lt;&lt; t &lt;&lt; endl;
    wait(10,SC_NS);
  }
};</pre></blockquote><h4 class=CHeading>SV Example</h4><p>In SV, target components provide an &ldquo;imp&rdquo; object for connecting to the outside world.&nbsp; The <i>imp</i> delegates to the interface implementations provided in the component.</p><img src="../../images/UVMC_TLM_Overview_Imps.png" width="377" height="137"><blockquote><pre>class consumer extends uvm_component;

  uvm_blocking_put_imp #(packet,consumer) in;  &lt;-- imp object

  `uvm_component_utils(consumer)

   function new(string name, uvm_component parent=null);
      super.new(name,parent);
      in = new(&quot;in&quot;,  this);
   endfunction

   virtual task put (packet t);   &lt;-- implementation
     `uvm_info(&quot;CONSUMER/PKT/RECV&quot;,
                t.sprint(),UVM_MEDIUM)
     #10ns;
   endtask

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Exports" href="../../uvmc/docs/TLM_REVIEW.txt">Exports</a></h3><div class=CBody><p>Exports promote an interface (or imp) implementation from a child to its parent.</p><ul><li>Promotes (exports) interface implementations from a child  (or self) up a level</li><li>Internally bound to child export, imp / interface in c&rsquo;tor</li><li>Externally connected to port or parent export, but not required.&nbsp; (If no connection, no activity)</li><li>Exports are depicted as circle in diagrams</li></ul><h4 class=CHeading>SC Example</h4><p>Often, an SC component that implements an interface may provide that interface via an explicit export object, much like the <i>imp</i> provides an interface in SV.&nbsp; In this case, the SC Target binds its own interface implementation to the export.&nbsp; Then, a port can be connected directly to the export, e.g.&nbsp; <i>prod.out.bind(cons.in);</i></p><img src="../../images/UVMC_TLM_Overview_Export_Self.png" width="377" height="138"><blockquote><pre>class consumer : public sc_module,
                 tlm_blocking_put_if&lt;packet&gt;
{
  public:

  sc_export&lt;tlm_blocking_put_if&lt;packet&gt; &gt; in;  &lt;-- export

  consumer(sc_module_name nm) : in(&quot;in&quot;) {
    in(*this);                  &lt;-- promote own intf impl
  }

 virtual void put(const packet &amp;t) {
    cout &lt;&lt; &quot;Got packet: &quot; &lt;&lt; t &lt;&lt; endl;
    wait(10,SC_NS);
  }
};</pre></blockquote><h4 class=CHeading>SV Example</h4><img src="../../images/UVMC_TLM_Overview_Export_Imp.png" width="403" height="148"><blockquote><pre>class parent extends uvm_component;

  uvm_blocking_put_export #(packet) in;

  consumer cons;

  `uvm_component_utils(consumer)

  function new(string name, uvm_component parent=null);
     super.new(name,parent);
     in = new(&quot;in&quot;,  this);
  endfunction

  function void build_phase(uvm_phase phase);
    cons=consumer::type_id::create(&quot;const&quot;,this);
  endfunction

  function void connect_phase(uvm_phase phase);
    in.connect(consumer.in);
  endfunction

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Analysis" href="../../uvmc/docs/TLM_REVIEW.txt">Analysis</a></h3><div class=CBody><p>Analysis ports, exports, and imps are used to monitor transaction flow and help you debug your designs.&nbsp; Components emitting transactions out an analysis port are not necessarily the producers of those transactions.&nbsp; In all cases, components receiving transactions from an analysis connection do not execute them or modify them in any way.</p><h4 class=CHeading>Analysis Ports</h4><p>Analysis ports are a special kind of TLM port.&nbsp; They publish transactions to any number of listeners, including zero.</p><ul><li>Broadcasts (&ldquo;publishes&rdquo;) to all connected targets (&ldquo;subscribers&rdquo;)</li><li>Transactions are read-only.&nbsp; Used for debug, scoreboards, etc.</li><li>Usually does not require connection (SC_ZERO_OR_MORE_BOUND)</li><li>Depicted as diamond in diagrams</li></ul><h4 class=CHeading>SC Example</h4><img src="../../images/UVMC_TLM_Overview_Analysis_Ports.png" width="287" height="138"><blockquote><pre>class monitor: public sc_module
{
  sc_port&lt;tlm_analysis_if&lt;packet&gt;,
          0, SC_ZERO_OR_MORE_BOUND&gt; &gt; ap;

  monitor(sc_module_name nm) : ap(&quot;ap&quot;){
     SC_THREAD(run);
  }
  void run() {
     packet t;
     ...gather packet off bus...
     ap-&gt;write( t );  &lt;--
  }
};</pre></blockquote><h4 class=CHeading>Analysis Exports &amp; Imps</h4><p>Analysis exports and imps are subscribers to a TLM analysis port.</p><ul><li>Receives streams of transactions from connected publisher (e.g. monitor)</li><li>Transactions are read-only, i.e. for debugging, scoreboarding, etc.</li><li>Like all exports and imps, does not typically <i>require</i> a connection</li><li>Depicted as circle in diagrams</li></ul><h4 class=CHeading>SV Example</h4><img src="../../images/UVMC_TLM_Overview_Analysis_Imps.png" width="401" height="145"><blockquote><pre>class scoreboard extends uvm_component;

   uvm_analysis_imp #(packet,scoreboard) actual_in;  &lt;-- imp

   `uvm_component_utils(scoreboard)

   function new(string name, uvm_component parent=null);
      super.new(name,parent);
      actual_in = new(&quot;actual_in&quot;, this);
      ...
   endfunction

   virtual function void write(packet t); &lt;-- called by actual_in
     packet exp;
     `uvm_info(&quot;SB/PKT/RECV&quot;,t.sprint(),UVM_MEDIUM)
     if (!expect_fifo.try_get(exp)) ...error
     if (!t.compare(exp)) ...error
   endfunction
endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=7 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="TLM_Initiator_Socket" href="../../uvmc/docs/TLM_REVIEW.txt">TLM Initiator Socket</a></h3><div class=CBody><p>Sockets are a convenient way to make TLM2 connections; in fact, most TLM2 connections are made with sockets, not individual interface connections.</p><ul><li>Can do blocking or non-blocking transport (usually one or the other)</li><li>Default type is <i>tlm_generic_payload</i> with base protocol semantics</li><li>Initiator must implement backward interface, unless a simple initiator socket is used (in tlm_utils namespace)</li><li>When driving an SV target, the <i>DMI</i> and <i>debug</i> interface calls will be ignored, as they are not implemented in SV.</li><li>When driving an SC target from SV, the <i>DMI</i> and <i>debug</i> interfaces will not be called, so your SC models should not rely on them being called.</li><li>Depicted as square with outward facing arrow</li></ul><h4 class=CHeading>SC Example</h4><img src="../../images/UVMC_TLM_Overview_InitiatorSocket.png" width="449" height="105"><blockquote><pre>struct producer: public sc_module,
                 public tlm_bw_transport_if&lt; &gt;
{
  tlm::tlm_initiator_socket&lt; &gt; out; // default: tlm_gp

  producer (sc_module_name nm) : out(&quot;out&quot;) {
    out(*this); // bind bw intf to self
    SC_THREAD(fw_proc);
  }

  // FORWARD PATH

  void fw_proc() {
    // produce tlm gp trans, then emit using...
    out-&gt;b_transport(t,del);
       *or*
    out-&gt;nb_transport_fw(t,ph,del);
  }

  // BACKWARD PATH

  virtual tlm_sync_enum nb_transport_bw(...) {
    ...coordinate with fw path, per protocol
  }

  virtual void invalidate_direct_mem_ptr(...) {
    // Dummy implementation
  }
};</pre></blockquote></div></div></div>




 <!--CONTENT index=8 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="TLM_Target_Socket" href="../../uvmc/docs/TLM_REVIEW.txt">TLM Target Socket</a></h3><div class=CBody><p>A component having a target socket receives transaction on its forward interface and, if non-blocking, sends responses to the initiator via the backward path.</p><p>Some other key aspects of target sockets include</p><ul><li>They implement both blocking or non-blocking transport interface, although the connected initiator typically uses one or the other.</li><li>The default transaction type is the <i>tlm_generic_payload</i> executed with <i>TLM base protocol</i> semantics</li><li>The target model must implement all of forward interface unless the simple target socket is used, in which case only those methods that are registered need to be implemented.</li><li>Because UVM SV does not support the direct memory and debug interfaces, UVMC stubs these out.&nbsp; Attempts to use these interfaces by SV initiators will be ignored.</li><li>Sockets are depicted in diagrams as a square with inward facing arrow.</li></ul><img src="../../images/UVMC_TLM_Overview_TargetSocket.png" width="511" height="111"><h4 class=CHeading>SC example</h4><blockquote><pre>struct consumer: public sc_module,
                 public tlm_fw_transport_if&lt; &gt; {

  tlm::tlm_target_socket&lt; &gt; in;

  consumer(sc_module_name nm) : in(&quot;in&quot;) {
    in.bind(*this);     SC_THREAD(bw_proc);
  }

  // FORWARD PATH

  void b_transport( packet&amp; trans,sc_time&amp; t ) {
    // fully execute request, modify args, return
  }

  tlm_sync_enum nb_transport_fw(...) {
    // per protocol, update args as allowed,return
  }

  bool get_direct_mem_ptr() { return FALSE; }

  unsigned int transport_dbg() { return 0; }


  // BACKWARD PATH

  void bw_proc() {
     ...coordinate with fw transport per protocol
     in-&gt;nb_transport_bw(trans,ph,delay);
  }
};</pre></blockquote></div></div></div>




 <!--CONTENT index=9 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Socket_Connections" href="../../uvmc/docs/TLM_REVIEW.txt">Socket Connections</a></h3><div class=CBody><p>A socket is used to connect a forward and backward path between an initiator and target using a single <i>connect</i> or <i>bind</i> call.&nbsp; Although sockets support both blocking and non-blocking semantics, typically only one of them is in play for any given connection.</p><h4 class=CHeading>Blocking Transport</h4><ul><li>Initiator indirectly calls <i>b_transport</i> in Target</li><li>Initiator must not modify transaction; transaction contents invalid until <i>b_transport</i> returns</li><li>When <i>b_transport</i> returns, transaction is complete with status/results</li><li>Transaction can be reused in next <i>b_transport</i> call</li></ul><img src="../../images/UVMC_TLM_Overview_BTransportSocket.png" width="444" height="144"><h4 class=CHeading>Non-blocking Transport using Base Protocol</h4><ul><li>Initiator starts request by calling <i>nb_transport_fw</i> in Target.&nbsp; Target returns with updated arguments.</li><li>Target can call <i>nb_transport_bw</i> in Initiator at phase transitions.&nbsp; To provide Initiator updates; Initiator may respond via fw interface.</li><li>Transaction contents, phase, &amp; delay can change.&nbsp; Only certain fields in certain phases, according to base protocol rules.</li><li>Transport calls continue back and forth until either returns transaction complete status.&nbsp; For efficiency, the same transaction handle is used throughout its execution.</li></ul><img src="../../images/UVMC_TLM_Overview_NBTransportSocket.png" width="601" height="271"></div></div></div>




 <!--CONTENT index=10 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Legal_TLM_Connections" href="../../uvmc/docs/TLM_REVIEW.txt">Legal TLM Connections</a></h3><div class=CBody><p>TLM port connections are like Verilog module port connections except you&rsquo;re connecting interfaces not wires.&nbsp; Control and data flow through each TLM connection can be in opposite directions.</p><p>A successful connection requires a given pair of ports to agree on the interface and transaction types as well as the direction of control and data flow.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Ports</td><td class=CDLDescription>Ports can connect/bind to parent ports, sibling exports, and sibling interfaces/imps.&nbsp; <i>prod.port.bind(port|export|intf|imp)</i></td></tr><tr><td class=CDLEntry>Exports</td><td class=CDLDescription>Exports can connect/bind to child exports and child interfaces/imps.&nbsp; <i>export.bind(export|imp|interface)</i></td></tr><tr><td class=CDLEntry>Interfaces (SC)</td><td class=CDLDescription>Interfaces in Systemc are pure virtual classes that are inherited by target.&nbsp; They are never on the left-hand side of a bind or connect call.</td></tr><tr><td class=CDLEntry>Imps (SV)</td><td class=CDLDescription>Imps in SV are implicitly bound to the parent in the parent&rsquo;s constructor.&nbsp; <i>imp = new(&ldquo;name&rdquo;, this)</i>, where <i>this</i> is the parent.&nbsp;  They are never on the left-hand side of a bind or connect call.</td></tr></table><img src="../../images/UVMC_TLM_Overview_ITPC_Connections.png" width="462" height="345"><p>A connection is hierarchical when a port connects to a parent port or an export connects to a child export, interface, or imp.&nbsp;  The following figure shows the legal port-export-imp-interface connections.&nbsp; Passthrough TLM sockets in SV UVM are used to make hierarchical socket connections.</p><img src="../../images/UVMC_TLM_Overview_Hierarchical.png" width="465" height="216"></div></div></div>




 <!--CONTENT index=11 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="TLM_Generic_Payload" href="../../uvmc/docs/TLM_REVIEW.txt">TLM Generic Payload</a></h3><div class=CBody><p>TLM 2.0 defines a canonical transaction type, <i>tlm_generic_payload</i>, or <i>tlm_gp</i> for short.&nbsp; TLM 2.0 also defines a base protocol for execution of the generic payload over standard initiator and target sockets.</p><p>When used together--<i>tlm_gp</i> with the <i>base protocol</i>--interoperability potential is at its highest.</p><p>The TLM GP defines the following major fields.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>command</td><td class=CDLDescription>READ, WRITE, or IGNORE</td></tr><tr><td class=CDLEntry>address</td><td class=CDLDescription>Base address</td></tr><tr><td class=CDLEntry>data</td><td class=CDLDescription>Data buffer.&nbsp; An array of bytes</td></tr><tr><td class=CDLEntry>data_length</td><td class=CDLDescription>Number of valid bytes in data buffer</td></tr><tr><td class=CDLEntry>response_status</td><td class=CDLDescription>OK, INCOMPLETE, GENERIC_ERROR, ADDRESS_ERROR, BURST_ERROR, etc.</td></tr><tr><td class=CDLEntry>byte_enable</td><td class=CDLDescription>Byte-enable data buffer</td></tr><tr><td class=CDLEntry>byte_enable_length</td><td class=CDLDescription>Number of valid byte-enables buffer</td></tr></table><p>Between SystemC, UVM, and the UVMC libraries, the tlm generic payload transaction definitions and converters come pre-defined for you.&nbsp; You do not need to define converters for <i>tlm_gp</i>.&nbsp; You can just connect and go!</p></div></div></div>




 <!--CONTENT index=12 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="TLM1_combination_interfaces" href="../../uvmc/docs/TLM_REVIEW.txt">TLM1 combination interfaces</a></h3><div class=CBody><p>TLM ports <i>require</i> a connection to an implementation of its interface type, while TLM exports, interfaces, and imps <i>provide</i> the implementation.&nbsp; As long as the provider provides <i>at least</i> the required interface, the connection is allowed.</p><p>In most connections, you will be connecting TLM ports that are typed to matching interfaces, e.g. a <i>uvm_tlm_blocking_put_port #(my_trans)</i> would be connected to a <i>uvm_tlm_blocking_put_imp #(my_trans)</i>, or in SC, an <i>sc_port&lt; tlm_blocking_put_if&lt;my_trans&gt; &gt;</i> would be connected to a component implementing (inheriting) <i>tlm_blocking_put_if&lt;my_trans&gt;</i>.</p><p>To increase connection options for integrators, a VIP designer may opt to provide both the blocking and non-blocking interfaces, e.g. provide a <i>uvm_tlm_put_imp #(my_tras)</i>.&nbsp; Integrators may connect to this any of <i>uvm_tlm_blocking_put_port #(my_trans)</i>, <i>uvm_tlm_nonblocking_put_port #(my_trans)</i>,  or of course <i>uvm_tlm_put_port #(my_trans)</i>.</p><p>As you will see in the chapter on <a href="../examples/connections/README-txt.html#UVMC_Connections" class=LSection id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">UVMC Connections</a>, the same options when making connections that cross the language boundary.</p></div></div></div>




 <!--CONTENT index=13 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="UVMC_TLM_Connections" href="../../uvmc/docs/TLM_REVIEW.txt">UVMC TLM Connections</a></h3><div class=CBody><p>Getting your SystemC TLM models and SystemVerilog UVM components talking to each other breaks down to two steps</p><ul><li>Define converters, if necessary</li><li>Make connections</li></ul><p>If you&rsquo;re not using the TLM generic payload, you must define compatible transaction classes in SV and SC and the converters to go between them.&nbsp; If the transactions and the components that use them are pre-existing, this task entails writing a custom converter class that not only packs and unpacks but adapts to the differences in member types, member number, and declaration order between the two classes.</p><p>If a transaction type pre-exists in one language but not the other, you would need to define the missing transaction type first, then define the converters to go between it and the original transaction.&nbsp; Try to define the class to match the existing definition as closely as possible.</p><p>In UVM, your transaction should extend uvm_sequence_item.&nbsp; It must implement the <i>do_pack</i> and <i>do_unpack</i> methods, or it must use the <i>`uvm_field</i> macros (not recommended).&nbsp; The number, order, and manner of unpacking must be compatible with that for unpacking.&nbsp; Typically, one is the exact reverse of the other.</p><blockquote><pre>//------------------------------------------------------------//
//   Copyright 2009-2015 Mentor Graphics Corporation          //
//   All Rights Reserved Worldwide                            //
//                                                            //
//   Licensed under the Apache License, Version 2.0 (the      //
//   &quot;License&quot;); you may not use this file except in          //
//   compliance with the License.  You may obtain a copy of   //
//   the License at                                           //
//                                                            //
//       http://www.apache.org/licenses/LICENSE-2.0           //
//                                                            //
//   Unless required by applicable law or agreed to in        //
//   writing, software distributed under the License is       //
//   distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR   //
//   CONDITIONS OF ANY KIND, either express or implied.  See  //
//   the License for the specific language governing          //
//   permissions and limitations under the License.           //
//------------------------------------------------------------//</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CGroup>A partial list of sources for information on SystemC, SystemVerilog, UVM, and related topics</div></div><div class=CToolTip id="tt2"><div class=CSection>This chapter shows how to make TLM connections between SystemC and SystemVerilog UVM components.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>