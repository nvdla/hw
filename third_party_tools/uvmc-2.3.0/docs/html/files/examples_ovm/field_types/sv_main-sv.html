<html><head><title>Data Type Support</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CExample"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="Data_Type_Support" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">Data Type Support</a></h1><div class=CBody><p>This example shows a full implementation of a UVM-compliant transaction type whose fields represent all the data types supported by the UVMC library.&nbsp; Although the example defines all the <i>do_*</i> operations, UVMC requires only <i>do_pack</i> and <i>do_unpack</i>.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Contents</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td class=SEntry><a href="#Data_Type_Support" >Data Type Support</a></td><td class=SDescription>This example shows a full implementation of a UVM-compliant transaction type whose fields represent all the data types supported by the UVMC library. </td></tr>
  <!-- index=1 -->

<tr class="SSMethod SMarked"><td class=SEntry><a href="#packet" id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">packet</a></td><td class=SDescription>Defines a packet class containing a field for each of the data types supported by UVMC.</td></tr>
  <!-- index=11 -->

<tr class="SSMethod"><td class=SEntry><a href="#producer" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">producer</a></td><td class=SDescription>A simple producer that generates packet transactions and sends them out its <i>out</i> blocking-put and <i>ap</i> analysis ports.</td></tr>
  <!-- index=12 -->

<tr class="SSMethod SMarked"><td class=SEntry><a href="#scoreboard" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">scoreboard</a></td><td class=SDescription>A simple scoreboard that implements in-order comparison of <i>expect</i> and <i>actual</i> packets. </td></tr>
  <!-- index=13 -->

<tr class="SModule"><td class=SEntry><a href="#sv_main" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">sv_main</a></td><td class=SDescription>Creates an instance of a <a href="#producer" class=LClass id=link5 onMouseOver="ShowTip(event, 'tt2', 'link5')" onMouseOut="HideTip('tt2')">producer</a> and <a href="#scoreboard" class=LClass id=link6 onMouseOver="ShowTip(event, 'tt3', 'link6')" onMouseOut="HideTip('tt3')">scoreboard</a>, makes both native and cross-language connections using UVM Connect, then calls <i>run_test</i>.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="packet" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">packet</a></h2><div class=CBody><p>Defines a packet class containing a field for each of the data types supported by UVMC.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>integrals</td><td class=CDLDescription>bit, byte, shortint, int, longint long, and their unsigned counterparts.</td></tr><tr><td class=CDLEntry>enum</td><td class=CDLDescription>user-defined enumeration types are packed by their numeric value.&nbsp; A compatible enumeration type must be defined on the SC side.</td></tr><tr><td class=CDLEntry>reals</td><td class=CDLDescription>shortreal and real translate to SC-side float and double, respectively.</td></tr><tr><td class=CDLEntry>strings</td><td class=CDLDescription>use only for ASCII strings.&nbsp; Use vector&lt;char&gt; for an array of bytes whose elements can include the &lsquo;0&rsquo; value</td></tr><tr><td class=CDLEntry>arrays</td><td class=CDLDescription>fixed arrays, queues, dynamic arrays, and associate arrays are supported as long as the element and key types are among the supported types.&nbsp; These types are analogous to the STL vector&lt;T&gt;, list&lt;T&gt;, and map&lt;KEY,T&gt; types in C++.</td></tr><tr><td class=CDLEntry>time</td><td class=CDLDescription>packed as 64-bit values.&nbsp; Equates to the SC &lsquo;sc_time&rsquo; type.</td></tr><tr><td class=CDLEntry>sc data types</td><td class=CDLDescription>The SV bit-vector and logic-vector types are mapped to any of the following SC built-in types: sc_bit, sc_logic, sc_bv&lt;N&gt;, sc_lv&lt;N&gt;, sc_int&lt;N&gt;, sc_uint&lt;N&gt;, sc_bigint&lt;N&gt;, and sc_biguint&lt;N&gt;, for any valid width, N. For any given N, the SV-side declaration should be <i>bit [N-1:0] var_name</i>.&nbsp; See the SC-side definition of <i>packet</i>.</td></tr></table><p>Although <a href="#packet.do_pack" class=LMethod id=link8 onMouseOver="ShowTip(event, 'tt5', 'link8')" onMouseOut="HideTip('tt5')">do_pack</a> and <a href="#packet.do_unpack" class=LMethod id=link9 onMouseOver="ShowTip(event, 'tt6', 'link9')" onMouseOut="HideTip('tt6')">do_unpack</a> are the only methods required by UVMC, this example also implements <a href="#packet.do_copy" class=LMethod id=link10 onMouseOver="ShowTip(event, 'tt7', 'link10')" onMouseOut="HideTip('tt7')">do_copy</a>, <a href="#packet.do_compare" class=LMethod id=link11 onMouseOver="ShowTip(event, 'tt8', 'link11')" onMouseOut="HideTip('tt8')">do_compare</a>, <a href="#packet.do_print" class=LMethod id=link12 onMouseOver="ShowTip(event, 'tt9', 'link12')" onMouseOut="HideTip('tt9')">do_print</a>, and <a href="#packet.do_record" class=LMethod id=link13 onMouseOver="ShowTip(event, 'tt10', 'link13')" onMouseOut="HideTip('tt10')">do_record</a>.&nbsp; There are many reasons for opting to implement the <i>do_*</i> methods as below instead of using the <i>`ovm_field</i> macros.&nbsp; For details, see the white paper, <i>OVM/UVM Macros: A Cost-Benefit Analysis</i>, at <a href="http://www.verificationacademy.com" class=LURL target=_top>http://www.verificationacademy.com</a>.</p><blockquote><pre>class packet extends ovm_object;

   // default converter assumes trans derives from ovm_object
   `ovm_object_utils(packet)

   function new(string name=&quot;&quot;);
     super.new(name);
   endfunction

    typedef enum { ADD, SUBTRACT, MULTIPLY, DIVIDE } cmds_t;

    rand cmds_t            enum32;

    rand longint           int64;
    rand int               int32;
    rand shortint          int16;
    rand byte              int8;
    rand bit               int1;

    rand longint unsigned  uint64;
    rand int unsigned      uint32;
    rand shortint unsigned uint16;
    rand byte unsigned     uint8;
    rand bit unsigned      uint1;

         real              real64;

    rand time              time64;

         string            str;

    rand int               arr[3];
    rand byte              q[$];
    rand shortint          da[];
         shortint          aa[shortint];

    rand sub_object        obj;

    rand bit               scbit;
    rand logic             sclogic;
    rand bit [16:0]        scbv;
    rand logic [34:0]      sclv;
    rand bit [5:0]         scint;
    rand bit [24:0]        scuint;
    rand bit [36:0]        scbigint;
    rand bit [61:0]        scbiguint;


    constraint C_q_size  { q.size  inside {[1:11]}; }
    constraint C_da_size { da.size inside {[1:11]}; }</pre></blockquote>

<!--START_ND_SUMMARY index=1-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=1 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#packet" id=link7 onMouseOver="ShowTip(event, 'tt1', 'link7')" onMouseOut="HideTip('tt1')">packet</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Defines a packet class containing a field for each of the data types supported by UVMC.</td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry>ovm_object</div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>packet</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class packet extends ovm_object
  </td></tr></table></blockquote></td></tr>

  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#packet.Methods" >Methods</a></td><td class=SDescription></td></tr>
  <!-- index=3 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#packet.do_pack" >do_pack</a></td><td class=SDescription>Converts this transaction&rsquo;s contents into a form transferrable outside SystemVerilog.</td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#packet.do_unpack" >do_unpack</a></td><td class=SDescription>Converts a bit-vector representation of a transaction into this transaction object.</td></tr>
  <!-- index=5 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#packet.do_copy" >do_copy</a></td><td class=SDescription>Copies the values of fields from another object of the same type into this object.</td></tr>
  <!-- index=6 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#packet.do_compare" >do_compare</a></td><td class=SDescription>Compares the values of fields with those of another object of the same type, returning 1 if a match, 0 otherwise.</td></tr>
  <!-- index=7 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#packet.do_print" >do_print</a></td><td class=SDescription>Implements printing of all fields in this transaction using the provided <i>printer</i> policy class.</td></tr>
  <!-- index=8 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#packet.do_record" >do_record</a></td><td class=SDescription>Records all members of this transaction class for later viewing in the GUI&rsquo;s wave window.</td></tr>
  <!-- index=9 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#packet.pre_randomize" >pre_randomize</a></td><td class=SDescription>Randomizes the string variable, <i>str</i>, and associative array, <i>aa</i>.</td></tr>
  <!-- index=10 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#packet.pre_randomize" >pre_randomize</a></td><td class=SDescription>Provides rough randomization of real and shortreal fields by casting randomized integrals to reals then taking their quotients.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="packet.Methods" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">Methods</a></h3></div></div>




 <!--CONTENT index=3 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.do_pack" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">do_pack</a></h3><div class=CBody><p>Converts this transaction&rsquo;s contents into a form transferrable outside SystemVerilog.</p><p>Each field is packed using the smaller, more efficient packing macros included in UVM.&nbsp; Associative arrays are packed by first packing its size in a 32-bit value.&nbsp; Then, you pack each key-value pair use the macro appropriate for their types.</p><p>Subobjects are packed by calling <i>packer.pack_object(subob);</i>.</p><p>If your transaction extends a base class with its own fields, call <i>super.do_pack(packer)</i> before packing anything in this class.</p><blockquote><pre>virtual function void do_pack(ovm_packer packer);

  packer.pack_field_int(enum32,32);
  packer.pack_field_int(int64,64);
  packer.pack_field_int(int32,32);
  packer.pack_field_int(int16,16);
  packer.pack_field_int(int8,8);
  packer.pack_field_int(int1,1);
  packer.pack_field_int(uint64,64);
  packer.pack_field_int(uint32,32);
  packer.pack_field_int(uint16,16);
  packer.pack_field_int(uint8,8);
  packer.pack_field_int(uint1,1);
  packer.pack_field_int(scbit,1);
  packer.pack_field_int(sclogic,1);
  packer.pack_field_int(scbv,17);
  packer.pack_field_int(sclv,35);
  packer.pack_field_int(scint,6);
  packer.pack_field_int(scuint,25);
  packer.pack_field_int(scbigint,37);
  packer.pack_field_int(scbiguint,62);
  packer.pack_time(time64);
  packer.pack_real(real64);
  packer.pack_string(str);

  foreach (arr[i]) begin
    packer.pack_field_int(arr[i],32);
  end

  packer.pack_field_int(q.size(),32);
  foreach (q[i]) begin
    packer.pack_field_int(q[i],8);
  end

  packer.pack_field_int(da.size(),32);
  foreach (da[i]) begin
    packer.pack_field_int(da[i],16);
  end

  packer.pack_field_int(aa.size(),32);
  foreach (aa[i]) begin
    packer.pack_field_int(i,16);
    packer.pack_field_int(aa[i],16);
  end

  packer.pack_object(obj);

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.do_unpack" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">do_unpack</a></h3><div class=CBody><p>Converts a bit-vector representation of a transaction into this transaction object.</p><p>The order and manner of unpacking must be identical to how packing was performed.&nbsp; Packing an object then unpacking into a new instance of the object should be equivalent to copying the original object, minus any fields that were not packed.</p><p>Each field is unpacked using the smaller, more efficient unpacking macros included in UVM.</p><p>Associative arrays are packed by first packing its size in a 32-bit value.&nbsp; Then, you pack each key-value pair use the macro appropriate for their types.</p><p>To unpack sub-objects, first call <i>packer.is_null()</i> to determine if the packed sub-object is null or now.&nbsp; If not, you set this transaction&rsquo;s sub-object to null.&nbsp; If <i>is_null</i> returns 0, then alloate <i>obj</i> if its null and call <i>packer.unpack_object()</i>.</p><p>If your transaction extends a base class with its own fields, call <i>super.do_unpack(packer)</i> before unpacking anything in this class.</p><p>Instead of the macros, you could call methods of the packer for every field, just as you do for sub-objects.&nbsp; However, packing of built-in integral types is less efficient, and there is no methods for unpacking arrays.</p><blockquote><pre>virtual function void do_unpack(ovm_packer packer);

  int unsigned n;

  n = packer.unpack_field_int(32);
  enum32 = cmds_t'(n);

  int64     = packer.unpack_field_int(64);
  int32     = packer.unpack_field_int(32);
  int16     = packer.unpack_field_int(16);
  int8      = packer.unpack_field_int(8);
  int1      = packer.unpack_field_int(1);
  uint64    = packer.unpack_field_int(64);
  uint32    = packer.unpack_field_int(32);
  uint16    = packer.unpack_field_int(16);
  uint8     = packer.unpack_field_int(8);
  uint1     = packer.unpack_field_int(1);
  scbit     = packer.unpack_field_int(1);
  sclogic   = packer.unpack_field_int(1);
  scbv      = packer.unpack_field_int(17);
  sclv      = packer.unpack_field_int(35);
  scint     = packer.unpack_field_int(6);
  scuint    = packer.unpack_field_int(25);
  scbigint  = packer.unpack_field_int(37);
  scbiguint = packer.unpack_field_int(62);
  time64    = packer.unpack_time();
  real64    = packer.unpack_real();
  str       = packer.unpack_string();


  foreach (arr[i]) begin
    arr[i] = packer.unpack_field_int(32);
  end

  n = packer.unpack_field_int(32);
  q.delete();
  for (int i=0; i&lt;n; i++) begin
    q.push_back(packer.unpack_field_int(8));
  end

  n = packer.unpack_field_int(32);
  da = new[n];
  for (int i=0; i&lt;n; i++) begin
    da[i] = packer.unpack_field_int(16);
  end

  aa.delete();
  n = packer.unpack_field_int(32);
  for (int i=0; i&lt;n; i++) begin
    shortint k, val;
    k = packer.unpack_field_int(16);
    val = packer.unpack_field_int(16);
    aa[k]=val;
  end

  if (packer.is_null())
    obj = null;
  else begin
    if (obj == null)
      obj = new();
    packer.unpack_object(obj);
  end

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.do_copy" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">do_copy</a></h3><div class=CBody><p>Copies the values of fields from another object of the same type into this object.</p><p>Do_copy uses the assignment operator for all built-in types.&nbsp; Subobjects are copied by calling <i>subobj.copy(_rhs.subobj)</i>.</p><p>If your transaction extends a base class with its own fields, call <i>super.do_copy(rhs)</i> before copying anything in this class.</p><blockquote><pre>function void do_copy(ovm_object rhs);

  packet _rhs;
  assert($cast(_rhs,rhs));

  enum32    = _rhs.enum32;
  int64     = _rhs.int64;
  int32     = _rhs.int32;
  int16     = _rhs.int16;
  int8      = _rhs.int8;
  int1      = _rhs.int1;
  uint64    = _rhs.uint64;
  uint32    = _rhs.uint32;
  uint16    = _rhs.uint16;
  uint8     = _rhs.uint8;
  uint1     = _rhs.uint1;
  time64    = _rhs.time64;
  str       = _rhs.str;
  arr       = _rhs.arr;
  q         = _rhs.q;
  da        = _rhs.da;
  aa        = _rhs.aa;
  real64    = _rhs.real64;
  scbit     = _rhs.scbit;
  sclogic   = _rhs.sclogic;
  scbv      = _rhs.scbv;
  sclv      = _rhs.sclv;
  scint     = _rhs.scint;
  scuint    = _rhs.scuint;
  scbigint  = _rhs.scbigint;
  scbiguint = _rhs.scbiguint;
  obj.copy(_rhs.obj);
endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.do_compare" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">do_compare</a></h3><div class=CBody><p>Compares the values of fields with those of another object of the same type, returning 1 if a match, 0 otherwise.</p><p>Use the boolean equality operator (==) for most built-in types.&nbsp;  It is more efficient than the provided methods in the <i>comparer</i> policy class.</p><p>If you opt to employ direct comparison with the == operator as in this example, you must still set the <i>comparer.result</i> to 0 if there were no miscompares, or to if there was a miscompare.</p><p>Leverage short-circuit expression evaluation for higher efficiency.&nbsp; Expression evaluation stops as soon as a result is certain.&nbsp; For example, given an expression <i>(a &amp;&amp; b &amp;&amp; c &amp;&amp; d)</i>, if <i>a</i> or <i>b</i> are 0, the whole expression evaluates to 0, so there is no point in examining <i>c</i> or <i>d</i>.&nbsp; The expression evaluates to 0 no matter what their values.&nbsp; In this <i>packet</i> class, if the <i>int64</i> property doesn&rsquo;t match with the right hand side, the remaining 25 equality comparisons that follow are not evaluated, thus speeding up the comparison operation considerably.</p><p>Comparison of scalars is more efficient than comparison of arrays and other composite types  (e.g. sub-objects).&nbsp; So, put composite types at the end of the expression.&nbsp; That way, these types will not be compared unless all the previous expression terms evaluate to true.</p><p>Subobjects are compared by calling <i>subobj.compare(_rhs.subobj,comparer)</i>.</p><p>If your transaction extends a base class with its own fields, call <i>super.do_compare(rhs,comparer)</i> before comparing any fields of this class.&nbsp; If <i>super.do_compare</i> returns 0, return immediately with 0.&nbsp; Otherwise, continue with comparing this transaction&rsquo;s fields.</p><blockquote><pre>function bit do_compare(ovm_object rhs, ovm_comparer comparer);

  packet _rhs;
  assert($cast(_rhs,rhs));
  comparer.result = 1;

  do_compare =
          enum32    == _rhs.enum32 &amp;&amp;
          int64     == _rhs.int64 &amp;&amp;
          int32     == _rhs.int32 &amp;&amp;
          int16     == _rhs.int16 &amp;&amp;
          int8      == _rhs.int8 &amp;&amp;
          int1      == _rhs.int1 &amp;&amp;
          uint64    == _rhs.uint64 &amp;&amp;
          uint32    == _rhs.uint32 &amp;&amp;
          uint16    == _rhs.uint16 &amp;&amp;
          uint8     == _rhs.uint8 &amp;&amp;
          uint1     == _rhs.uint1 &amp;&amp;
          time64    == _rhs.time64 &amp;&amp;
          str       == _rhs.str &amp;&amp;
          arr       == _rhs.arr &amp;&amp;
          q         == _rhs.q &amp;&amp;
          da        == _rhs.da &amp;&amp;
          scbit     == _rhs.scbit &amp;&amp;
          sclogic   == _rhs.sclogic &amp;&amp;
          scbv      == _rhs.scbv &amp;&amp;
          sclv      == _rhs.sclv &amp;&amp;
          scint     == _rhs.scint &amp;&amp;
          scuint    == _rhs.scuint &amp;&amp;
          scbigint  == _rhs.scbigint &amp;&amp;
          scbiguint == _rhs.scbiguint &amp;&amp;
          $realtobits(real64) == $realtobits(_rhs.real64)
          ;

  if (!do_compare)
    return 0;

  // temporary limitation: assoc arrays must be compared &quot;item by item&quot;
  if (aa.size() != _rhs.aa.size())
    return 0;
  foreach (aa[i])
    if (!(_rhs.aa.exists(i) &amp;&amp; aa[i] == _rhs.aa[i]))
      return 0;

  // compare sub-object deeply
  if (obj == null) begin
    if (_rhs.obj != null)
      return 0;
  end
  else
    do_compare = obj.compare(_rhs.obj,comparer);

  comparer.result = 1-do_compare;

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=7 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.do_print" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">do_print</a></h3><div class=CBody><p>Implements printing of all fields in this transaction using the provided <i>printer</i> policy class.</p><p>To cut down on repetitive typing, small macros are used to &ldquo;inline&rdquo; verbose calls to <i>printer.print_generic</i>.</p><p>If your transaction extends a base class with its own fields, call <i>super.do_print(printer)</i> before printing any fields of this class.</p><blockquote><pre>virtual function void do_print(ovm_printer printer);

  `define do_print_int(VAR,TYP,SZ) \
    printer.print_generic(`&quot;VAR`&quot;, `&quot;TYP`&quot;,SZ,$sformatf(&quot;'h%h&quot;,VAR));

  `define do_print_ele(VAR,TYP,SZ) \
    printer.print_generic($sformatf(&quot;[%0d]&quot;,i),\
          `&quot;TYP`&quot;,SZ,$sformatf(&quot;'h%h&quot;,VAR));

  printer.print_generic(&quot;cmd&quot;,&quot;cmds_t&quot;,32,enum32.name());
  `do_print_int(int64,     longint,           64)
  `do_print_int(int32,     int,               32)
  `do_print_int(int16,     shortint,          16)
  `do_print_int(int8,      byte,               8)
  `do_print_int(int1,      bit,                1)
  `do_print_int(uint64,    longint unsigned,  64)
  `do_print_int(uint32,    int unsigned,      32)
  `do_print_int(uint16,    shortint unsigned, 16)
  `do_print_int(uint8,     byte unsigned,      8)
  `do_print_int(uint1,     bit unsigned,       1)
  `do_print_int(scbit,     bit,                1)
  `do_print_int(sclogic,   logic,              1)
  `do_print_int(scbv,      bit[16:0],         17)
  `do_print_int(sclv,      bit[34:0],         35)
  `do_print_int(scint,     bit[5:0],           6)
  `do_print_int(scuint,    bit[24:0],         25)
  `do_print_int(scbigint,  bit[36:0],         37)
  `do_print_int(scbiguint, bit[61:0],         62)
  printer.print_time   (&quot;time64&quot;,time64);
  printer.print_field_real   (&quot;real64&quot;,real64);
  printer.print_string (&quot;str&quot;,  str);

  // print arrays one element at a time, between a header
  // and footer
  printer.print_array_header(&quot;arr&quot;,3,&quot;int[3]&quot;);
  foreach (arr[i])
    `do_print_ele(arr[i],int,32)
  printer.print_array_footer(3);

  printer.print_array_header(&quot;q&quot;,q.size(),&quot;byte[$]&quot;);
  foreach (q[i])
    `do_print_ele(q[i],byte,8)
  printer.print_array_footer(q.size());

  printer.print_array_header(&quot;da&quot;,da.size(),&quot;shortint[]&quot;);
  foreach (da[i])
    `do_print_ele(da[i],shortint,16)
  printer.print_array_footer(da.size());

  printer.print_array_header(&quot;aa&quot;,aa.num(),&quot;shortint[shortint]&quot;);
  foreach (aa[i])
    `do_print_ele(aa[i],shortint,16)
  printer.print_array_footer(aa.num());

  printer.print_object(&quot;obj&quot;,obj);

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=8 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.do_record" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">do_record</a></h3><div class=CBody><p>Records all members of this transaction class for later viewing in the GUI&rsquo;s wave window.</p><p>This implementation uses the small <i>uvm_record_field</i> macro to record most field types.&nbsp; Arrays are recorded iteratively using the same macro.</p><p>To record a subobject, call the recorder&rsquo;s <i>record_object</i> method.</p><p>The component&rsquo;s <i>end_tr</i> method indirectly calls this method, but only if its <i>recording_detail</i> configuration parameter is set to something above OVM_NONE.</p><p>If your transaction extends a base class with its own fields, call <i>super.do_record(recorder)</i> before recording any fields of this class.</p><blockquote><pre>virtual function void do_record(ovm_recorder recorder);

  /* RECORD FUNCTIONALITY not needed for OVMC demo */
  /*
  int unsigned real_bits32;
  int unsigned n;
  `uvm_record_field(&quot;enum32&quot;,enum32)
  `uvm_record_field(&quot;int64&quot;,int64)
  `uvm_record_field(&quot;int32&quot;,int32)
  `uvm_record_field(&quot;int16&quot;,int16)
  `uvm_record_field(&quot;int8&quot;,int8)
  `uvm_record_field(&quot;int1&quot;,int1)
  `uvm_record_field(&quot;uint64&quot;,uint64)
  `uvm_record_field(&quot;uint32&quot;,uint32)
  `uvm_record_field(&quot;uint16&quot;,uint16)
  `uvm_record_field(&quot;uint8&quot;,uint8)
  `uvm_record_field(&quot;uint1&quot;,uint1)
  `uvm_record_time(&quot;time64&quot;,time64)
  `uvm_record_field(&quot;real64&quot;,real64)
  `uvm_record_string(&quot;str&quot;,str)
  foreach(arr[i])
    `uvm_record_field($sformatf(&quot;arr[%0d]&quot;,i),arr[i])
  foreach(q[i])
    `uvm_record_field($sformatf(&quot;q[%0d]&quot;,i),q[i])
  foreach(da[i])
    `uvm_record_field($sformatf(&quot;da[%0d]&quot;,i),da[i])
  foreach (aa[i]) begin
    string val = $sformatf(&quot;'h%h&quot;,aa[i]);
    `uvm_record_field($sformatf(&quot;aa[%0d]&quot;,i),val)
  end
  recorder.record_object(&quot;obj&quot;,obj);

  `uvm_record_field(&quot;scbit&quot;,scbit);
  `uvm_record_field(&quot;sclogic&quot;,sclogic);
  `uvm_record_field(&quot;scbv&quot;,scbv);
  `uvm_record_field(&quot;sclv&quot;,sclv);
  `uvm_record_field(&quot;scint&quot;,scint);
  `uvm_record_field(&quot;scuint&quot;,scuint);
  `uvm_record_field(&quot;scbigint&quot;,scbigint);
  `uvm_record_field(&quot;scbiguint&quot;,scbiguint);
  */
endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=9 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.pre_randomize" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">pre_randomize</a></h3><div class=CBody><p>Randomizes the string variable, <i>str</i>, and associative array, <i>aa</i>.</p><p>For strings, we randomize its length to be within a narrow range, then randomize each character to be within the range of printable characters.</p><p>For the associative array, we randomize its size (number of entries) to be within a narrow range, then randomize each key/value pair.</p><blockquote><pre>function void pre_randomize();
  int aa_size;
  int str_size;

  // randomize assoc array
  void'(std::randomize(aa_size) with { aa_size inside {[4:11]}; });
  aa.delete();
  for (int i=0; i &lt; aa_size; i++) begin
    shortint key;
    shortint val;
    key = $urandom;
    val = $urandom;
    aa[key] = val;
  end

  // randomize string
  void'(std::randomize(str_size) with { str_size inside {[4:11]}; });
  str = &quot;&quot;;
  for (int i=0; i &lt; str_size; i++) begin
    byte ele;
    void'(std::randomize(ele) with { ele inside {[32:126]}; });
$sformat(str, &quot;%s%x&quot;, str, ele); // str = {str, string'(ele)};
  end

  // allocate sub-object
  if (obj == null)
     obj = new(&quot;obj&quot;);

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=10 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="packet.pre_randomize" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">pre_randomize</a></h3><div class=CBody><p>Provides rough randomization of real and shortreal fields by casting randomized integrals to reals then taking their quotients.</p><blockquote><pre>    function void post_randomize();
      // reals derive from quotient of two randomized ints
      real64 = real'(uint64) / real'(uint32);
    endfunction

endclass : packet</pre></blockquote></div></div></div>




 <!--CONTENT index=11 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="producer" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">producer</a></h2><div class=CBody><p>A simple producer that generates packet transactions and sends them out its <i>out</i> blocking-put and <i>ap</i> analysis ports.</p><blockquote><pre>class producer extends ovm_component;

   ovm_blocking_put_port #(packet) out;
   ovm_analysis_port #(packet) ap;

   `ovm_component_utils(producer)

   function new(string name, ovm_component parent=null);
      super.new(name,parent);
      out = new(&quot;out&quot;, this);
      ap = new(&quot;ap&quot;, this);
   endfunction : new

   virtual task run();

     packet pkt;

     ovm_test_done.raise_objection(this);

     for (int i = 1; i &lt;= NUM_PKTS; i++) begin
       pkt = new;
       assert(pkt.randomize());

       `ovm_info(&quot;PRODUCER/SEND&quot;,
          $sformatf(&quot;Sending packet #%0d&quot;,i),OVM_MEDIUM)
          pkt.print();

       ap.write(pkt);
       out.put(pkt);

     end

       `ovm_info(&quot;PRODUCER/STOP&quot;, &quot;Stopping the test&quot;, OVM_LOW);

     ovm_test_done.drop_objection(this);

   endtask

endclass</pre></blockquote>

<!--START_ND_SUMMARY index=11-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=11 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#producer" id=link14 onMouseOver="ShowTip(event, 'tt2', 'link14')" onMouseOut="HideTip('tt2')">producer</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>A simple producer that generates packet transactions and sends them out its <i>out</i> blocking-put and <i>ap</i> analysis ports.</td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry>ovm_component</div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>producer</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class producer extends ovm_component
  </td></tr></table></blockquote></td></tr>
</table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=12 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="scoreboard" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">scoreboard</a></h2><div class=CBody><p>A simple scoreboard that implements in-order comparison of <i>expect</i> and <i>actual</i> packets.&nbsp; The <i>expect</i> packets arrive via the <i>expect_in</i> analysis export.&nbsp; They are stored in an internal FIFO for later comparison with incoming <i>actual</i> packets, which arrive on its <i>actual_in</i> analysis imp.&nbsp; Strict comparison is performed as each <i>actual</i> arrives.</p><blockquote><pre>`ovm_analysis_imp_decl(_expect)
`ovm_analysis_imp_decl(_actual)

class scoreboard extends ovm_component;

   packet expect_q[$];
   int drain_time = 10;
   ovm_analysis_imp_expect  #(packet, scoreboard) expect_in;
   ovm_analysis_imp_actual  #(packet, scoreboard) actual_in;

   `ovm_component_utils(scoreboard)

   function new(string name, ovm_component parent=null);
      super.new(name,parent);
      actual_in   = new(&quot;actual_in&quot;, this);
      expect_in   = new(&quot;expect_in&quot;, this);
      enable_stop_interrupt = 1;
   endfunction : new

   virtual function void write_expect(packet t);
     expect_q.push_back(t);
   endfunction

   virtual function void write_actual(packet t);
     packet exp;

     `ovm_info(&quot;SCOREBD/RECV_ACTUAL&quot;,
            $sformatf(&quot;SV scoreboard recevied actual:\n  %p&quot;,t),OVM_HIGH);

     if (expect_q.size() == 0)
       `ovm_fatal(&quot;SCOREBD/NO_EXPECT&quot;,
         $psprintf(&quot;%m: No expect packet to compare with incoming actual.&quot;))

     exp = expect_q.pop_front();

     if (!exp.compare(t))
       `ovm_error(&quot;SCOREBD/MISCOMPARE&quot;,
         $psprintf(&quot;Actual does not match expect:\nexpect=%p\nactual=%p&quot;,
           exp,t))
   endfunction

   virtual task stop(string ph_name);
     if (expect_q.size()) begin
       `ovm_info(&quot;SCOREBD/EXPECT_Q_NOT_EMPTY&quot;,
         $psprintf(&quot;Expect Q still has %0d outstanding transactions. Waiting %0d time units&quot;,
                   expect_q.size(),drain_time),OVM_NONE)
       #drain_time;
       if (expect_q.size()) begin
         `ovm_error(&quot;SCOREBD/EXPECT_Q_NOT_EMPTY&quot;,
           $psprintf(&quot;Expect Q still has %0d outstanding transactions after waiting %0d time units&quot;,
                     expect_q.size(),drain_time))
           foreach(expect_q[i]) begin
             $display(&quot;  expect_q[&quot;,i,&quot;]=&quot;,expect_q[i].convert2string());
           end
       end
     end
     else begin
       `ovm_info(&quot;SCOREBD/STOP_REQUEST&quot;,&quot;Expect Q is empty. OK to end the run phase&quot;, OVM_NONE)
     end
   endtask

endclass</pre></blockquote>

<!--START_ND_SUMMARY index=12-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=12 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#scoreboard" id=link15 onMouseOver="ShowTip(event, 'tt3', 'link15')" onMouseOut="HideTip('tt3')">scoreboard</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>A simple scoreboard that implements in-order comparison of <i>expect</i> and <i>actual</i> packets. </td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry>ovm_component</div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>scoreboard</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=2>`ovm_analysis_imp_decl(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PParameter nowrap width=100%>_expect</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=2>) `ovm_analysis_imp_decl(_actual) class scoreboard extends ovm_component</td></tr>
      </table></td></tr>
    </table></blockquote>
</td></tr>
</table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=13 -->
<div class="CModule"><div class=CTopic><h2 class=CTitle><a name="sv_main" href="../../../uvmc/examples_ovm/field_types/sv_main.sv">sv_main</a></h2>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>module sv_main
  </td></tr></table></blockquote><div class=CBody><p>Creates an instance of a <a href="#producer" class=LClass id=link19 onMouseOver="ShowTip(event, 'tt2', 'link19')" onMouseOut="HideTip('tt2')">producer</a> and <a href="#scoreboard" class=LClass id=link20 onMouseOver="ShowTip(event, 'tt3', 'link20')" onMouseOut="HideTip('tt3')">scoreboard</a>, makes both native and cross-language connections using UVM Connect, then calls <i>run_test</i>.</p><blockquote><pre>module sv_main;

  import ovmc_pkg::*;

  producer prod;
  scoreboard sb;

  initial begin

    prod = new(&quot;prod&quot;);
    sb = new(&quot;sb&quot;);

    // expect path = normal TLM connection between producer and scoreboard
    prod.ap.connect(sb.expect_in);

    // actual path - SC-side consumer to SV-side scoreboard
    uvmc_tlm1 #(packet)::connect(prod.out,&quot;foo&quot;);
    uvmc_tlm1 #(packet)::connect(sb.actual_in,&quot;bar&quot;);

    run_test();

  end

endmodule</pre></blockquote>

<!--START_ND_SUMMARY index=13-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=13 -->

<tr class="SModule"><td class=SEntry><a href="#sv_main" id=link16 onMouseOver="ShowTip(event, 'tt4', 'link16')" onMouseOut="HideTip('tt4')">sv_main</a></td><td class=SDescription>Creates an instance of a <a href="#producer" class=LClass id=link17 onMouseOver="ShowTip(event, 'tt2', 'link17')" onMouseOut="HideTip('tt2')">producer</a> and <a href="#scoreboard" class=LClass id=link18 onMouseOver="ShowTip(event, 'tt3', 'link18')" onMouseOut="HideTip('tt3')">scoreboard</a>, makes both native and cross-language connections using UVM Connect, then calls <i>run_test</i>.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class packet extends ovm_object
  </td></tr></table></blockquote>Defines a packet class containing a field for each of the data types supported by UVMC.</div></div><div class=CToolTip id="tt2"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class producer extends ovm_component
  </td></tr></table></blockquote>A simple producer that generates packet transactions and sends them out its <i>out</i> blocking-put and <i>ap</i> analysis ports.</div></div><div class=CToolTip id="tt3"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=2>`ovm_analysis_imp_decl(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PParameter nowrap width=100%>_expect</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=2>) `ovm_analysis_imp_decl(_actual) class scoreboard extends ovm_component</td></tr>
      </table></td></tr>
    </table></blockquote>
A simple scoreboard that implements in-order comparison of <i>expect</i> and <i>actual</i> packets. </div></div><div class=CToolTip id="tt4"><div class=CModule>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>module sv_main
  </td></tr></table></blockquote>Creates an instance of a producer and scoreboard, makes both native and cross-language connections using UVM Connect, then calls <i>run_test</i>.</div></div><div class=CToolTip id="tt5"><div class=CMethod>Converts this transaction&rsquo;s contents into a form transferrable outside SystemVerilog.</div></div><div class=CToolTip id="tt6"><div class=CMethod>Converts a bit-vector representation of a transaction into this transaction object.</div></div><div class=CToolTip id="tt7"><div class=CMethod>Copies the values of fields from another object of the same type into this object.</div></div><div class=CToolTip id="tt8"><div class=CMethod>Compares the values of fields with those of another object of the same type, returning 1 if a match, 0 otherwise.</div></div><div class=CToolTip id="tt9"><div class=CMethod>Implements printing of all fields in this transaction using the provided <i>printer</i> policy class.</div></div><div class=CToolTip id="tt10"><div class=CMethod>Records all members of this transaction class for later viewing in the GUI&rsquo;s wave window.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>