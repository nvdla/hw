<html><head><title>UVMC Connection Example - SC to SV, SC side</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="UVMC_Connection_Example-SC_to_SV,SC_side" href="../../../uvmc/examples_ovm/connections/sc2sv.cpp">UVMC Connection Example - SC to SV, SC side</a></h1><div class=CBody><p>This example shows a SC producer driving a SV consumer via a TLM connection made with UVMC, including how to derive a SC producer subtype that can control UVM phasing using the UVMC Command API.&nbsp; See <a href="sc2sv-sv.html#UVMC_Connection_Example-SC_to_SV,SV_side" class=LSection >UVMC Connection Example - SC to SV, SV side</a> to see the SV portion of the example.</p><img src="../../../images/UVMC_Connections_SC2SV.png" width="401" height="110"><p>In a pure SC simulation, synchronization between a producer and consumer occurs exclusively through the protocol prescribed by the TLM standard.&nbsp; In mixed SC-SV simulation, SC usually elaborates and starts its threads before SV has finished elaborating.&nbsp; To prevent run-time errors, UVMC will block any cross-language access until SV is ready.&nbsp; This means calls to interface methods via SC ports or sockets connected to SV must be made from within SC threads (via the SC_THREAD macro or sc_spawn).</p><p>Blocking until SV is ready technically violates TLM non-blocking semantics.&nbsp; It was deemed more useful to hold back activity from all cross-language calls rather than reject all non-blocking calls until SV was ready.&nbsp; Future releases may provide an option to return immediately with 0 status from non-blocking calls.</p><p>When a UVM testbench is sitting on the SV side, you must also consider UVM&rsquo;s phasing semantics, which says that a phase will end if there are no objections raised to its ending.&nbsp; When, as in this example, there is a SC-side participant to UVM phase control, an objection will need to be raised from the SC side for the phase(s) in which the SC side actively participates.&nbsp; The producer, in other words, must use the UVMC Command API to raise and drop the objection that corresponds to the phase in which it is generating stimulus.&nbsp; If it does not, then UVM (SV) will end that phase and likely end simulation before the SC producer has had a chance to emit the first transaction.</p><p>To preserve reuse, it is recommended that the UVM Command API usage be relegated to a subtype of the native SC producer.&nbsp; This way, you do not couple the producer&rsquo;s primary functionality (producing transactions) with cross-language synchronization issues and UVMC.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#UVMC_Connection_Example-SC_to_SV,SC_side" >UVMC Connection Example - SC to SV, SC side</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This example shows a SC producer driving a SV consumer via a TLM connection made with UVMC, including how to derive a SC producer subtype that can control UVM phasing using the UVMC Command API. </td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#UVM-aware_SC_producer" >UVM-aware SC producer</a></td><td class=SDescription>This example defines the <i>producer_uvm</i> class, which derives from our generic SC <i>producer</i>. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#sc_main" >sc_main</a></td><td class=SDescription>The <i>sc_main</i> function below creates and starts the SC portion of this example. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="UVM-aware_SC_producer" href="../../../uvmc/examples_ovm/connections/sc2sv.cpp">UVM-aware SC producer</a></h3><div class=CBody><p>This example defines the <i>producer_uvm</i> class, which derives from our generic SC <i>producer</i>.&nbsp; In it, we spawn a dynamic <i>objector</i> thread that calls <i>uvmc_raise_objection</i> to UVM&rsquo;s run phase.&nbsp; This keeps simulation alive on the SV side while the base <i>producer</i> in SC generates stimulus.</p><p>When the base <i>producer</i> is finished generating stimulus, it will notify a <i>done</i> sc_event.&nbsp; The <i>objector</i> thread in this <i>producer_uvm</i> wakes up on that event notification and drops its objection using <i>uvmc_drop_objection</i>.&nbsp; This allows UVM simulation to proceed to the next phase and eventually complete simulation.</p><blockquote><pre>#include &quot;uvmc.h&quot;
using namespace uvmc;

#include &quot;producer.h&quot;

class producer_uvm : public producer {

  public:

  producer_uvm(sc_module_name nm) : producer(nm) {
    SC_THREAD(objector);
  }

  SC_HAS_PROCESS(producer_uvm);

  void objector() {
    uvmc_raise_objection(&quot;run&quot;);
    wait(done);
    uvmc_drop_objection(&quot;run&quot;);
  }

};</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="sc_main" href="../../../uvmc/examples_ovm/connections/sc2sv.cpp">sc_main</a></h3><div class=CBody><p>The <i>sc_main</i> function below creates and starts the SC portion of this example.&nbsp; It does the following:</p><ul><li>Instantiates a basic <i>producer</i></li><li>Registers the producer&rsquo;s <i>in</i> port with UVMC using the lookup string &ldquo;42&rdquo;.&nbsp; During elaboration, UVMC will connect this port with a port registered with the same lookup string.&nbsp; In this example, the match will occur with a consumer&rsquo;s <i>in</i> port on the SV side.</li><li>Calls <i>sc_start</i> to start SystemC</li></ul><blockquote><pre>int sc_main(int argc, char* argv[])
{
  producer_uvm prod(&quot;producer&quot;);
  uvmc_connect(prod.out,&quot;42&quot;);
  sc_start(-1);
  return 0;
}</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>